;   Простой пример программы для KolibriOS
;   озвучивает код нажатой клавиши
;
;   Компилировать FASM'ом
;        Можно открыть example.asm через программу FASM (её ярлык есть
;        на рабочем столе)
;        А можно просто нажать F9 в Tinypad'е. Лог компиляции 
;        отображается на доске отладки (программа BOARD)
;
;   Что важно знать при программировании под Колибри:
;        Номер функции помещается в регистр eax.
;        Вызов системной функции осуществляется командой "int 0x40".
;        Все регистры, кроме явно указанных в возвращаемом значении,
;        включая регистр флагов eflags, сохраняются.
;
;    Пример:
;        mov eax, 1    ;Функция 1 - поставить точку в окне
;                      ;список сисфункций см. в DOCPACK - sysfuncr.txt
;        mov ebx, 10   ; координата x=10
;        mov ecx, 20   ; координата y=10
;        mov edx, 0xFFFfff ;цвет точки
;        int 0x40      ;вызвать функцию
;
;    Тоже самое с использованием макроса:
;        mcall 1, 10, 20, 0xFFFfff
;---------------------------------------------------------------------

  use32              ; включить 32-битный режим ассемблера
  org    0           ; адресация с нуля

  db     'MENUET01'  ; 8-байтный идентификатор MenuetOS
  dd     1           ; версия заголовка (1 либо 2, см. док-ю)
  dd     START       ; адрес первой команды
  dd     I_END       ; размер программы
  dd     MEM         ; количество памяти
  dd     STACKTOP    ; адрес вершины стэка
  dd     0           ; адрес буфера для параметров
  dd     0           ; зарезервировано

include "macros.inc" ; макросы облегчают жизнь ассемблерщиков!

;---------------------------------------------------------------------
;---  НАЧАЛО ПРОГРАММЫ  ----------------------------------------------
;---------------------------------------------------------------------

START:

red:                    ; перерисовать окно

    call draw_window    ; вызываем процедуру отрисовки окна

;---------------------------------------------------------------------
;---  ЦИКЛ ОБРАБОТКИ СОБЫТИЙ  ----------------------------------------
;---------------------------------------------------------------------

still:
    mcall 10            ; функция 10 - ждать события

    cmp  eax,1          ; перерисовать окно ?
    je   red            ; если да - на метку red
    cmp  eax,2          ; нажата клавиша ?
    je   key            ; если да - на key
    cmp  eax,3          ; нажата кнопка ?
    je   button         ; если да - на button

    jmp  still          ; если другое событие - в начало цикла


;---------------------------------------------------------------------


  key:                  ; нажата клавиша на клавиатуре
    mcall 2             ; функция 2 - считать код символа (в ah)

    mov  [Music+1], ah  ; записать код символа как код ноты

    ; функция 55-55: системный динамик ("PlayNote")
    ;   esi - адрес мелодии

    ;   mov  eax,55
    ;   mov  ebx,eax
    ;   mov  esi,Music
    ;   int  0x40

    ; или коротко:
    mcall 55, eax, , , Music

    jmp  still          ; вернуться к началу цикла

;---------------------------------------------------------------------

  button:
    mcall 17            ; 17 - получить идентификатор нажатой кнопки

    cmp   ah, 1         ; если НЕ нажата кнопка с номером 1,
    jne   still         ;  вернуться

  .exit:
    mcall -1            ; иначе конец программы


;---------------------------------------------------------------------
;---  ОПРЕДЕЛЕНИЕ И ОТРИСОВКА ОКНА  ----------------------------------
;---------------------------------------------------------------------

draw_window:

    mcall 12, 1       ; функция 12: сообщить ОС о начале отрисовки
	
    mcall 48, 3, sc,sizeof.system_colors
	
    ; далее: сначала длинный вариант (закомментированный)
    ; затем короткий аналог с использованием макросов

;   mov  eax,0                   ; функция 0: определить окно
;   mov  ebx,200*65536+300       ; [x старт] *65536 + [x размер]
;   mov  ecx,200*65536+150       ; [y старт] *65536 + [y размер]
;   mov  edx, [sc.work]          ; цвет фона
;   or   edx, 0x33000000         ; и тип окна 3
;   mov  edi,header              ; ЗАГОЛОВОК ОКНА
;   int  0x40

    mov   edx, [sc.work]         ; цвет фона
    or    edx, 0x33000000        ; и тип окна 3
    mcall 0, <200,300>, <200,150>, , ,title

    ; вывод текстовой строки
    mov   ecx, [sc.work_text]    ; цвет фона
    or    ecx, 0x90000000        ; и тип строки
    mcall 4, <10, 20>, , message


    mcall 12, 2                  ; функция 12.2, закончили рисовать

    ret                          ; выходим из процедуры


;---------------------------------------------------------------------
;---  ДАННЫЕ ПРОГРАММЫ  ----------------------------------------------
;---------------------------------------------------------------------

; Вот такая вот короткая "мелодия".
; Второй байт изменяется нажатием клавишы

Music:
  db  0x90, 0x30, 0

sc system_colors

message db 'Нажмите любую клавишу...',0
title db 'Пример программы',0

;---------------------------------------------------------------------

I_END:                  ; метка конца программы
  rb 4096               ; память для стека
align 16
STACKTOP:               ; метка вершины стека (при заполнении стек
                        ; растет в сторону уменьшения адресов, потому
                        ; память для него в коде программы встречается
                        ; раньше чем его вершина)
MEM:                    ; метка указывающая на конец программы плюс
                        ; размер используемой ею оперативной памяти
; Адрес метки MEM всегда должен быть больше чем адрес метки I_END.
; Метка STACKTOP должна располагается после метки I_END и перед меткой
;   MEM. STACKTOP может находится и перед I_END, но это не правильно.
; Имена меток могут быть с любыми названиями, главное соблюдать
;   правильный порядок их расположения.