; макрос для системной библиотеки box_lib.obj
; элемент TextEditor для Kolibri OS
; файл последний раз изменялся 27.06.2014 IgorA
; на код применена GPL2 лицензия

;input:
; edi = pointer to tedit struct
; reg = index
;output:
; reg = pointer to 'tex' struct
macro ConvertIndexToPointer reg {
  imul reg,sizeof.symbol
  add reg,ted_tex
}

;--- out_reg = ted_key_words_data[ind_reg].Text[0] ---
macro ColToIndexOffset ind_reg,out_reg {
	mov out_reg,ind_reg
	imul out_reg,sizeof.TexColViv
	add out_reg,ted_key_words_data
}

macro use_text_edit
{
TED_PANEL_NULL	 equ 0 ;нет открытой панели
TED_PANEL_FIND	 equ 1 ;панель поиска
TED_PANEL_SYNTAX equ 2 ;панель выбора файлов подсветки
TED_PANEL_WIDTH  equ 150 ;ширина панели

MAX_COLOR_WORD_LEN equ 40
;------------------------------------------------------------------------------
struct TexSelect
  x0 dd ?
  y0 dd ?
  x1 dd ?
  y1 dd ?
ends

struct TexColViv
	Text  rb MAX_COLOR_WORD_LEN ; слово для подсветки
	f1    dd 0 ; справка по слову
	flags db ? ; f1+4 флаги используемые при выделении
	endc  db ? ; f1+5 символ конца выделения (используется при flags&4)
	escc  db ? ; f1+6 экранирующий символ (используется при flags&4)
	color db ? ; f1+7 номер цвета
ends

struct symbol
  c db ?    ;  +0 символ
  col db ?  ;  +1 цвет
  perv dd ? ;  +2
  next dd ? ;  +6 указатели
  tc dd ?   ; +10 врем. создания
  td dd ?   ; +14 врем. удаления
ends
;------------------------------------------------------------------------------

ted_symbol_tab db 26 ;ascii код стрелки вправо, используется для рисования табуляции в режиме показа невидимых символов

if lang eq ru

txtRow db 'Строка',0
txtCol db 'Знак',0
txtOtm db 'Отмены',0
txtBuf db 'Буфер:',0

else

txtRow db 'Rows',0
txtCol db 'Cols',0
txtOtm db 'Undo',0
txtBuf db 'Buffer:',0

end if

;EvChar - таблица для фильтрования добавляемых символов, что-бы не попали лишние знаки
align 4
EvChar db 0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0
    db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    db 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
    db 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
    db 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
    db 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
    db 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
    db 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0
    db 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
    db 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
    db 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
    db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    db 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
    db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

KM_SHIFT equ 0x00010000
KM_CTRL equ 0x00020000
KM_ALT equ 0x00040000
KM_NUMLOCK equ 0x00080000

; KEY CODES
KEY_F1 equ 0x0000003B
KEY_F2 equ 0x0000003C
KEY_F3 equ 0x0000003D



align 4
proc ted_init, edit:dword
	push eax ecx edi
	mov edi,dword[edit]

	mov ecx,sizeof.symbol
	imul ecx,ted_max_chars
	invoke mem.alloc,ecx ;выделяем память
	mov ted_tex,eax
	mov ted_tex_1,eax
	add ted_tex_1,sizeof.symbol
	add eax,ecx
	mov ted_tex_end,eax

	stdcall ted_clear, edi,1

;-------------------------------------------------
	mov ecx,1024 ;1024 - для массива ted_arr_key_pos
	add ecx,ted_syntax_file_size
	invoke mem.alloc,ecx
	mov ted_arr_key_pos,eax
	add eax,1024
	mov ted_syntax_file,eax

	stdcall ted_init_scroll_bars,edi,3
	pop edi ecx eax
	ret
endp

MIN_W_SCRL_ARE equ 3 ;минимальная отображаемая область для верт. скроллинга
MIN_H_SCRL_ARE equ 3 ;минимальная отображаемая область для гориз. скроллинга
;input:
; opt = 1 - менять цвет скроллингов, 2 - изменились размеры окна,
;  4 - изменились размеры документа
align 4
proc ted_init_scroll_bars, edit:dword, opt:dword
	pushad
	mov edi,dword[edit]
	mov esi,ted_scr_w
	mov ebx,ted_scr_h
	bt dword[opt],0
	jae @f
		mov ecx,ted_color_wnd_work
		mov dword[esi+sb_offs_bckg_col],ecx
		mov dword[ebx+sb_offs_bckg_col],ecx
		mov ecx,ted_color_wnd_capt
		mov dword[esi+sb_offs_frnt_col],ecx
		mov dword[ebx+sb_offs_frnt_col],ecx
		mov ecx,ted_color_wnd_bord
		mov dword[esi+sb_offs_line_col],ecx
		mov dword[ebx+sb_offs_line_col],ecx
	@@:
	bt dword[opt],2 ; изменились размеры документа ?
	jae .doc_resize
		call ted_get_num_lines
		cmp eax,100
		jge @f
			mov eax,100
		@@:
		mov dword[esi+sb_offs_max_area],eax
	.doc_resize:
	bt dword[opt],1 ; изменились размеры окна ?
	jae .no_size
			mov edx,ted_wnd_l
			add edx,ted_rec_l
			mov word[ebx+sb_offs_start_x],dx ;выставляем левый отступ гориз. скроллинга
		mov eax,ted_wnd_h ;calculate lines in page
			mov edx,ted_wnd_t
			add edx,eax
			mov word[ebx+sb_offs_start_y],dx ;выставляем верхний отступ гориз. скроллинга
		sub eax,ted_rec_t
		xor edx,edx
		mov ecx,ted_rec_h
		div ecx
		cmp eax,MIN_W_SCRL_ARE
		jg @f
			mov eax,MIN_W_SCRL_ARE
		@@:
		mov dword[esi+sb_offs_cur_area],eax

		mov eax,ted_wnd_w ;calculate cols in page
			mov edx,ted_wnd_l ;левый отступ окна
			add edx,eax ;добавляем ширину окна
			mov word[esi+sb_offs_start_x],dx ;выставляем левый отступ верт. скроллинга
			mov edx,ted_wnd_t
			mov word[esi+sb_offs_start_y],dx ;выставляем верхний отступ верт. скроллинга
			mov edx,ted_wnd_h
			mov word[esi+sb_offs_size_y],dx ;выставляем высоту верт. скроллинга
		sub eax,ted_rec_l
			mov word[ebx+sb_offs_size_x],ax ;выставляем ширину гориз. скроллинга
		xor edx,edx
		mov ecx,ted_rec_w
		div ecx
		cmp eax,MIN_H_SCRL_ARE
		jg @f
			mov eax,MIN_H_SCRL_ARE
		@@:
		dec eax
		mov dword[ebx+sb_offs_cur_area],eax ;устанавливаем число символов, которые влазят в экран для гориз. скроллинга
	.no_size:
	popad
	ret
endp

align 4
proc ted_delete, edit:dword
	push edi
	mov edi,dword[edit]
	invoke mem.free,ted_tex
	invoke mem.free,ted_arr_key_pos ;ted_syntax_file
	pop edi
	ret
endp


;input:
; eax = key kodes
align 4
proc ted_key, edit:dword, table:dword, control:dword
	pushad
	mov edi,dword[edit]
	mov esi,ted_el_focus
	cmp dword[esi],edi
	jne .end_key_fun ;элемент не в фокусе выходим из функции
	mov esi,dword[control]

	cmp ah,KEY_F1 ;[F1]
	jne @f
		stdcall ted_show_help_f1,edi
		jmp .end_key_fun
	@@:
	cmp ah,KEY_F3 ;[F3]
	jne @f
		stdcall ted_but_find_next,edi
		jmp .end_key_fun
	@@:

	test esi,KM_CTRL ;Ctrl+...
	jz .key_Ctrl
		cmp ah,24 ;Ctrl+O
		jne @f
			cmp ted_fun_on_key_ctrl_o,0
			je @f
				call ted_fun_on_key_ctrl_o
		@@:
		cmp ah,31 ;Ctrl+S
		jne @f
			cmp ted_fun_on_key_ctrl_s,0
			je @f
				call ted_fun_on_key_ctrl_s
		@@:
		cmp ah,33 ;Ctrl+F
		jne @f
		cmp ted_panel_id,TED_PANEL_FIND
		je @f
			cmp ted_fun_on_key_ctrl_f,0
			je @f
				call ted_fun_on_key_ctrl_f
		@@:
		cmp ah,44 ;Ctrl+Z
		jne @f
			stdcall ted_but_undo,edi
		@@:
		cmp ah,46 ;Ctrl+C
		jne @f
			stdcall ted_but_copy,edi
		@@:
		cmp ah,47 ;Ctrl+V
		jne @f
			stdcall ted_but_paste,edi
		@@:
		cmp ah,49 ;Ctrl+N
		jne @f
			cmp ted_fun_on_key_ctrl_n,0
			je @f
				call ted_fun_on_key_ctrl_n
		@@:
		cmp ah,199 ;Ctrl+Home
		jne @f
			call ted_key_ctrl_home
		@@:
		jmp .end_key_fun
	.key_Ctrl:

	test esi,KM_SHIFT ;Shift+...
	jz .key_Shift
		cmp ah,72 ;Shift+Up
		jne @f
			call ted_sel_key_up
		@@:
		cmp ah,75 ;Shift+Left
		jne @f
			call ted_sel_key_left
		@@:
		cmp ah,77 ;Shift+Right
		jne @f
			call ted_sel_key_right
		@@:
		cmp ah,80 ;Shift+Down
		jne @f
			call ted_sel_key_down
		@@:
		;mov ted_drag_k,1 ;начинаем выделение от клавиатуры
		jmp .key_MoveCur
	.key_Shift:
;-------------------------------------------------
	cmp ah,72 ;178 ;Up
	jne @f
		call ted_draw_cursor_sumb
		call ted_cur_move_up
		cmp dl,8
		jne .no_red_0
			call ted_scroll_set_redraw
			stdcall ted_draw,edi
			jmp @f
		.no_red_0:
		call ted_draw_main_cursor
		mov ted_drag_k,0 ;заканчиваем выделение от клавиатуры
	@@:
	cmp ah,80 ;177 ;Down
	jne @f
		call ted_draw_cursor_sumb
		call ted_cur_move_down
		cmp dl,8
		jne .no_red_1
			call ted_scroll_set_redraw
			stdcall ted_draw,edi
			jmp @f
		.no_red_1:
		call ted_draw_main_cursor
		mov ted_drag_k,0 ;заканчиваем выделение от клавиатуры
	@@:
	cmp ah,75 ;176 ;Left
	jne @f
		call ted_draw_cursor_sumb
		call ted_cur_move_left
		cmp dl,8
		jne .no_red_2
			call ted_scroll_set_redraw
			stdcall ted_draw,edi
			jmp @f
		.no_red_2:
		call ted_draw_main_cursor
		mov ted_drag_k,0 ;заканчиваем выделение от клавиатуры
	@@:
	cmp ah,77 ;179 ;Right
	jne @f
		call ted_draw_cursor_sumb
		call ted_cur_move_right
		cmp dl,8
		jne .no_red_3
			call ted_scroll_set_redraw
			stdcall ted_draw,edi
			jmp @f
		.no_red_3:
		call ted_draw_main_cursor
		mov ted_drag_k,0 ;заканчиваем выделение от клавиатуры
	@@:
	cmp ah,71 ;180 ;Home
	jne @f
		call ted_draw_cursor_sumb
		call ted_cur_move_x_first_char
		cmp dl,8
		jne .no_red_4
			call ted_scroll_set_redraw
			stdcall ted_draw,edi
			jmp @f
		.no_red_4:
		call ted_draw_main_cursor
		mov ted_drag_k,0 ;заканчиваем выделение от клавиатуры
	@@:
	cmp ah,79 ;181 ;End
	jne @f
		call ted_draw_cursor_sumb
		call ted_cur_move_x_last_char
		cmp dl,8
		jne .no_red_5
			call ted_scroll_set_redraw
			stdcall ted_draw,edi
			jmp @f
		.no_red_5:
		call ted_draw_main_cursor
		mov ted_drag_k,0 ;заканчиваем выделение от клавиатуры
	@@:
	cmp ah,73 ;184 ;PageUp
	jne @f
		call ted_cur_move_page_up
		cmp dl,0
		je @f
		call ted_scroll_set_redraw
		stdcall ted_draw,edi
	@@:
	cmp ah,81 ;183 ;PageDown
	jne @f
		call ted_cur_move_page_down
		cmp dl,0
		je @f
		call ted_scroll_set_redraw
		stdcall ted_draw,edi
		mov ted_drag_k,0 ;заканчиваем выделение от клавиатуры
	@@:
;-------------------------------------------------
	.key_MoveCur:

	;ниже пропускаются служебные клавиши, которые могут давать мусорные символы в окно
	cmp ah,42 ;[L Shift] когда нажат без других кнопок
	je .end_key_fun
	cmp ah,54 ;[R Shift] когда нажат без других кнопок
	je .end_key_fun
	cmp ah,58 ;[Caps Lock]
	je .end_key_fun
	cmp ah,69 ;[Pause Break]
	je .end_key_fun
	cmp ah,120 ;[Fn]
	je .end_key_fun
	cmp ah,0x80 ;if key up
	ja .end_key_fun

	cmp dword[table],0
	je @f
		stdcall KeyConvertToASCII, dword[table]
	@@:

	;mov ted_drag_k,0 ;заканчиваем выделение от клавиатуры

	lea edx,[EvChar] ;берем адрес таблицы с допустимыми символами
	add dl,ah
	jae @f
		add edx,0x100 ;если было переполнение при добавлении кода символа
	@@:
	cmp byte [edx],1
	jne @f
		mov ted_key_new,ah
		call ted_set_undo
		mov edx,ted_opt_ed_change_time+ted_opt_ed_move_cursor
		stdcall ted_sel_text_del,edx
		cmp al,1
		jne .del
			mov edx,ted_opt_ed_move_cursor
		.del:
		cmp ted_cur_ins,1
		je .no_ins_mod
			stdcall ted_text_del,edi,ted_opt_ed_change_time
			mov edx,ted_opt_ed_move_cursor
		.no_ins_mod:
		mov ecx,edi
		add ecx,ted_offs_key_new
		stdcall ted_text_add,edi,ecx,1,edx ;добавляем символ введенный с клавиатуры
		cmp ted_key_new,13
		jne .dr_m_win
			;если вставили символ новой строки
			mov ecx,ted_scr_w
			inc dword[ecx+sb_offs_max_area] ;увеличиваем размер вертикального скроллинга
			mov edx,ted_cur_y
			cmp edx,dword[ecx+sb_offs_cur_area]
			jl .no_change
				dec ted_cur_y ;курсор оставляем на месте
				inc dword[ecx+sb_offs_position] ;сдвигаем ползунок
			.no_change:
			stdcall ted_draw,edi
			jmp .dr_cur_l
		.dr_m_win:
			stdcall ted_draw_cur_line,edi
		.dr_cur_l:
		cmp ted_fun_draw_panel_buttons,0
		je @f
			call ted_fun_draw_panel_buttons
	@@:

	cmp ah,8 ;[<-]
	jne @f
		call ted_set_undo
		stdcall ted_sel_text_del,ted_opt_ed_change_time
		cmp al,1
		je .del_one_b
			stdcall ted_text_del,edi,ted_opt_ed_change_time+ted_opt_ed_move_cursor
		.del_one_b:
		stdcall ted_draw,edi
		cmp ted_fun_draw_panel_buttons,0
		je .end_key_fun
			call ted_fun_draw_panel_buttons
		jmp .end_key_fun
	@@:

	cmp ah,182 ;Delete
	jne @f
		call ted_set_undo
		stdcall ted_sel_text_del,ted_opt_ed_change_time
		cmp al,1
		je .del_one_d
			stdcall ted_text_del,edi,ted_opt_ed_change_time
		.del_one_d:
		stdcall ted_draw,edi
		cmp ted_fun_draw_panel_buttons,0
		je .end_key_fun
			call ted_fun_draw_panel_buttons
		jmp .end_key_fun
	@@:

	cmp ah,185 ;Ins
	jne @f
		call ted_draw_cursor_sumb
		xor ted_cur_ins,1
		call ted_draw_main_cursor
	@@:

	.end_key_fun:
	popad
	ret
endp

;output:
; al = 1 - can save
align 4
proc ted_can_save, edit:dword
	push ecx edi
	mov edi,dword[edit]

	mov ecx,ted_tim_ch
	sub ecx,ted_tim_undo
	mov al,1
	cmp ted_tim_ls,ecx
	jne @f
		dec al
	@@:
	pop edi ecx
	ret
endp

;input:
; edi = pointer to tedit struct
;output:
; al = 1 - selected
align 4
proc ted_is_select
  push ebx
  xor al,al
  cmp ted_drag_m,1
  je @f
    mov al,1
    mov ebx,ted_sel_x0
    cmp ebx,ted_sel_x1
    jne @f
    mov ebx,ted_sel_y0
    cmp ebx,ted_sel_y1
    jne @f
    xor al,al
  @@:
  pop ebx
  ret
endp

;input:
; edi = pointer to tedit struct
align 4
proc ted_sel_normalize
	push ecx esi
	push edi
		mov esi,edi
		add esi,ted_offs_sel
		add edi,ted_offs_seln
		mov ecx,sizeof.TexSelect
		rep movsb
	pop edi

	jmp @f
		.swp_f:
		mov ecx,ted_seln_x0
		m2m ted_seln_x0,ted_seln_x1
		mov ted_seln_x1,ecx

		mov ecx,ted_seln_y0
		cmp ecx,ted_seln_y1 ;(sel_y0>sel_y1)
		jle .end_f
		m2m ted_seln_y0,ted_seln_y1
		mov ted_seln_y1,ecx

		jmp .end_f
	@@:

	mov ecx,ted_seln_y0
	cmp ecx,ted_seln_y1 ;(sel_y0>sel_y1)
	jg .swp_f

	cmp ecx,ted_seln_y1 ;(sel_y0==sel_y1)
	jne .end_f
		mov ecx,ted_seln_x0
		cmp ecx,ted_seln_x1 ;(sel_x0>sel_x1)
		jg .swp_f

	.end_f:
	pop esi ecx
	ret
endp

;input:
; edi = pointer to tedit struct
;description:
; Функция вызываемая при начале выделения
align 4
proc ted_sel_start
	push eax ecx
		mov eax,ted_scr_h
		mov ecx,ted_cur_x
		add ecx,dword[eax+sb_offs_position]
		mov ted_sel_x0,ecx
		mov ted_sel_x1,ecx

		mov eax,ted_scr_w
		mov ecx,ted_cur_y
		add ecx,dword[eax+sb_offs_position]
		mov ted_sel_y0,ecx
		mov ted_sel_y1,ecx
	pop ecx eax
	ret
endp

;input:
; edi = pointer to tedit struct
;description:
; Функция вызываемая при перемещении выделения
align 4
proc ted_sel_move
	push eax ecx
		mov ecx,ted_cur_x
		mov eax,ted_scr_h
		add ecx,dword[eax+sb_offs_position]
		mov ted_sel_x1,ecx

		mov eax,ted_scr_w
		mov ecx,ted_cur_y
		add ecx,dword[eax+sb_offs_position]
		mov ted_sel_y1,ecx
	pop ecx eax
	cmp ted_fun_draw_panel_buttons,0 ;redraw toolbar (need to button Copy)
	je @f
		call ted_fun_draw_panel_buttons
	@@:
	ret
endp

;input:
; cl_al_mem = 1 - clear all memory
align 4
proc ted_clear, edit:dword, cl_al_mem:dword
	push ecx edi
	mov edi,dword[edit]

	mov ted_cur_x,0
	mov ted_cur_y,0
	mov ted_tim_ch,0
	mov ted_tim_ls,0
	mov ted_tim_co,0
	mov ted_tim_undo,0
	mov ted_help_id,-1
	mov ecx,sizeof.symbol
	shl ecx,1
	add ecx,ted_tex
	mov ted_ptr_free_symb,ecx

	mov ecx,ted_scr_w
	mov dword[ecx+sb_offs_position],0
	mov dword[ecx+sb_offs_max_area],100 ;число строк видимых в новом документе
	mov dword[ecx+sb_offs_redraw],1
	mov ecx,ted_scr_h
	mov dword[ecx+sb_offs_position],0
	mov dword[ecx+sb_offs_max_area],100 ;число символов видимых в новом документе

	mov ted_sel_x0,0
	mov ted_sel_y0,0
	mov ted_sel_x1,0
	mov ted_sel_y1,0

	cmp dword[cl_al_mem],0
	je .exit

	push edx
	mov ecx,sizeof.symbol
	imul ecx,ted_max_chars
	mov edx,ted_tex
	@@:
		mov byte [edx],0
		inc edx
	loop @b
	mov edx,ted_tex
	mov dword [edx+6],1
	pop edx

	.exit:
	pop edi ecx
	ret
endp


align 4
proc ted_init_syntax_file, edit:dword
	pushad
	mov edi,dword[edit]

	mov ecx,0x100
	mov edx,ted_arr_key_pos
	@@:
		mov dword[edx],-1
		add edx,4
	loop @b

	;init: ted_colors_text_count, ted_key_words_count, ...
	mov ted_colors_text_count,1
	mov ted_key_words_count,0
	mov ted_help_text_f1,0
	mov ted_help_id,-1 ;идентификатор слова для справки

	mov eax,edi ;сохраняем значение edi
	mov esi,ted_syntax_file
	add edi,ted_offs_count_colors
	mov ecx,9*4
	rep movsb
	mov edi,eax ;востанавливаем значение edi

	mov eax,ted_syntax_file
	add eax,32
	mov ted_text_colors,eax

	mov eax,ted_colors_text_count ;init: count_colors_text (offset to key words)
	add eax,8
	shl eax,2
	add eax,ted_syntax_file
	mov ted_key_words_data,eax

	mov ecx,ted_key_words_count ;init: ted_arr_key_pos (first key positions)
	xor eax,eax
	@@:
		ColToIndexOffset eax,edx
		xor ebx,ebx
		mov bl,byte[edx]
		shl bx,2
		mov esi,ted_arr_key_pos
		add esi,ebx
		cmp dword[esi],-1
		jne .no_ch_key
			mov dword[esi],eax
		.no_ch_key:
		inc eax
	loop @b

	;init: ted_help_text_f1
	mov ecx,ted_key_words_count ;количество ключевых слов
	imul ecx,sizeof.TexColViv   ;размер структуры с 1-м кл. сл.
	add ecx,ted_key_words_data  ;начало файла с кл. сл.
	mov ted_help_text_f1,ecx    ;метка в памяти, где начинется текст со справкой

	stdcall ted_init_scroll_bars,edi,1 ;меняем цвета скроллингов
	.no_colors:
	popad
	ret
endp

;input:
; ebx = file size
; edi = pointer to tedit struct
;description:
; Функция вызывается при открытии файла
align 4
proc ted_on_open_file
	push eax ;destination
	push ecx ;for cycle
	push edx ;source
	push esi

	stdcall ted_clear,edi,0 ;чистим не всю память, потому что ниже будем ее заполнять новыми даными

	;когда символ завершения строки только 10 (без 13)
	mov edx,ted_tex
	mov ecx,ebx
	@@:
		cmp byte[edx],13
		je .no_10 ;если найден символ 13, то 10-е игнорируем
		inc edx
		loop @b
	mov edx,ted_tex
	mov ecx,ebx
	.s_10:
		cmp byte[edx],10
		jne @f
			mov byte[edx],13 ;меняем 10-й символ конца строки
		@@:
		inc edx
		loop .s_10
	.no_10:

	;переводим открытый файл внутрь элемента t_edit
	mov eax,ebx
	mov ecx,ebx
	add eax,2
	ConvertIndexToPointer eax
	mov edx,ted_tex
	add edx,ebx
	push ebx
	@@:
		mov ebx,[edx]
		mov byte [eax],bl
		mov dword [eax+2],ecx
		inc dword [eax+2]
		mov dword [eax+6],ecx
		add dword [eax+6],3
		;mov byte[eax+1],0 ;col=0
		mov dword [eax+10],-1 ;tc=-1
		mov dword [eax+14],0 ;td=0

		cmp ecx,0
		je @f
		dec ecx
		dec edx
		sub eax,sizeof.symbol
		jmp @b
	@@:
	pop ebx
	add eax,2
	mov dword [eax],0 ; first sumbol 'perv=0'

	mov edx,ted_tex ; настройки начального служебного символа
	; begining sumbol 'perv=0' 'next=2'
	mov dword [edx+2],0
	mov dword [edx+6],2

	add edx,sizeof.symbol ; настройки конечного служебного символа
	mov dword [edx+6],0 ; last sumbol 'next=0'
	mov dword [edx+2],ebx ; last sumbol 'perv=last'
	inc dword [edx+2]
	mov dword [edx+10],0 ; ставим время создания равное 0, что бы символ правильно обрабатывался при открытии файлов больших 28 байт

	mov edx,ebx
	inc edx ;2 = rezerv sumbols
	imul edx,sizeof.symbol
	add edx,ted_tex
	mov dword [edx+6],1 ; last sumbol 'next=1'

	@@: ;clear memory, need if before was open big file
		add edx,sizeof.symbol
		cmp edx,ted_tex_end
		jge @f
			mov dword[edx+10],0
			mov dword[edx+14],0
		jmp @b
	@@:

	call ted_get_num_lines
	cmp eax,100
	jge @f
		mov eax,100
	@@:
	mov esi,ted_scr_w
	mov dword[esi+sb_offs_max_area],eax
	pop esi edx ecx eax

	call ted_text_colored
	stdcall ted_draw,edi
	cmp ted_fun_draw_panel_buttons,0
	je @f
		call ted_fun_draw_panel_buttons
	@@:
	ret
endp

;input:
; edx = pointer to symbol struct
; edi = pointer to tedit struct
;output:
; edx = pointer to 'perv' visible symbol struct
align 4
ted_iterat_perv:
	cmp ted_tim_undo,0
	je .else
	push ebx
	@@:
		mov edx,dword[edx+2]
		cmp edx,0
		je @f
		imul edx,sizeof.symbol
		add edx,ted_tex
		call ted_symbol_not_vis
		cmp bl,1
		je @b
		cmp byte[edx],10 ;пропуск символа с кодом 10
		je @b
	pop ebx
	ret
	@@:
	mov edx,ted_tex ;начало файла
	pop ebx
	ret
	.else:
		mov edx,dword[edx+2]
		cmp edx,0
		je @f
		imul edx,sizeof.symbol
		add edx,ted_tex
		cmp dword [edx+14],0
		jne .else
		cmp byte[edx],10 ;пропуск символа с кодом 10
		je .else
	ret
	@@:
	mov edx,ted_tex ;начало файла
	ret


;input:
; edx = pointer to symbol struct
; edi = pointer to tedit struct
;output:
; edx = pointer to 'next' visible symbol struct
align 4
ted_iterat_next:
	cmp ted_tim_undo,0
	je .else
	push ebx
	@@:
		mov edx,dword[edx+6]
		cmp edx,1
		jle @f
		imul edx,sizeof.symbol
		add edx,ted_tex

		call ted_symbol_not_vis
		cmp bl,1
		je @b
		cmp byte[edx],10 ;пропуск символа с кодом 10
		je @b
	pop ebx
	ret
	@@:
	mov edx,ted_tex_1 ;конец файла
	pop ebx
	ret
	.else:
		mov edx,dword[edx+6]
		cmp edx,1
		jle @f
		imul edx,sizeof.symbol
		add edx,ted_tex

		cmp dword [edx+14],0
		jne .else
		cmp byte[edx],10 ;пропуск символа с кодом 10
		je .else
	ret
	@@:
	mov edx,ted_tex_1 ;конец файла
	ret

;input:
; bl = symbol end of select
; bh = экранирующий символ (= 0 если нет проверки на них)
; edx = pointer to symbol struct
; edi = pointer to tedit struct
;description:
; найти следующую позицию указанного символа
align 4
ted_iterat_next_pos_char:
	push ax
	mov al,1 ;предыдущий символ, служит для сравнения с символом bh
	@@:
		cmp bl,byte[edx]
		je .found
		.no_found:
		cmp edx,ted_tex_1
		jle @f
			mov al,byte[edx]
			call ted_iterat_next
			jmp @b
	.found:
		cmp bh,al
		je .no_found
	@@:
	call ted_iterat_next
	pop ax
	ret

;input:
; edx = pointer to symbol struct
; edi = pointer to tedit struct
align 4
ted_iterat_perv_color_tag:
  @@:
    cmp byte[edx+1],0
    jne @f
    call ted_iterat_perv
    cmp edx,ted_tex_1
    jle @f
    jmp @b
  @@:
  ret

;input:
; edx = pointer to symbol struct
; edi = pointer to tedit struct
align 4
ted_iterat_next_color_tag:
  @@:
    call ted_iterat_next
    cmp byte[edx+1],0
    jne @f
    cmp edx,ted_tex_1
    jle @f
    jmp @b
  @@:
  ;call ted_iterat_next
  ret

;input:
; edx = pointer to symbol struct
; edi = pointer to tedit struct
;output:
; bl = 1 if sumbol not visible
; (tex[i].td+ted_tim_undo<=ted_tim_ch && tex[i].td) || (tex[i].tc>ted_tim_ch-ted_tim_undo)
align 4
ted_symbol_not_vis:
  push eax

  xor bl,bl

  cmp dword [edx+14],0
  je @f
  mov eax,[edx+14] ;eax=tex[i].td
  add eax,ted_tim_undo
  cmp eax,ted_tim_ch
  jg @f
    mov bl,1
    pop eax
    ret
  @@:

  mov eax,ted_tim_ch
  sub eax,ted_tim_undo
  cmp [edx+10],eax
  jle @f
    or bl,1
  @@:

  pop eax
  ret

;input:
; text:dword - pointer to text string
; add_opt:dword - options
align 4
proc ted_text_add, edit:dword, text:dword, t_len:dword, add_opt:dword
	locals
		new_spc dd ? ;count new spaces
		new_lin dd ? ;count new lines
	endl
;использование регистров внутри функции:
;eax - позиция для вставки текста
;ebx - для временных нужд, длинна вставляемого текста
;ecx - для временных нужд
;edx - указатель на структуру символа
	pushad
	cmp dword[t_len],1 ;проверяем длинну добвляемого текста
	jl .no_add ;когда длинна <1 прыгаем на конец функции, во избежание глюков

	mov edi,dword[edit]
	mov esi,dword[text]

	call ted_get_pos_by_cursor
	call ted_get_text_perv_pos
	call ted_get_text_arr_index ;eax=po_t

	mov dword[new_spc],0
	cmp ted_gp_opt,2
	je @f
		push eax ;c_sp=cur[cn].x+Scroller->XPos-StrLen(cur[cn].y+Scroller->YPos);
			mov eax,ted_scr_h
			mov eax,dword[eax+sb_offs_position]
			add eax,ted_cur_x ;eax - номер символа
			mov dword[new_spc],eax

			mov eax,ted_scr_w
			mov eax,dword[eax+sb_offs_position]
			add eax,ted_cur_y ;eax - номер строки
			call ted_strlen ;ebx = line len
			sub dword[new_spc],ebx ;от позиции курсора отнимаем длинну строки, узнаем колличество добавляемых пробелов
		pop eax
	@@:

	mov ebx,dword[t_len]

	mov dword[new_lin],0
	cmp ted_gp_opt,0
	jne @f
		push eax
			mov eax,ted_scr_w
			mov eax,dword[eax+sb_offs_position]
			add eax,ted_cur_y
			inc eax
			mov dword[new_lin],eax

			call ted_get_num_lines
			sub dword[new_lin],eax
			;увеличиваем линии в скроллинге на число добавленных дополнительных строк
			mov ecx,ted_scr_w
			add dword[ecx+sb_offs_max_area],eax ;увеличиваем размер вертикального скроллинга
		pop eax
	@@:

	mov edx,ted_ptr_free_symb
	.beg_cycle: ;for(i=...;i<ted_max_chars;i++)
		cmp dword [edx+10],0 ;if(!tex[i].tc && !tex[i].td)
		jne .u1f
		cmp dword [edx+14],0
		jne .u1f
			test dword[add_opt],ted_opt_ed_change_time ;if(n_tim) ted_tim_ch++;
			jz .no_tim
				inc ted_tim_ch
			.no_tim:
			test dword[add_opt],ted_opt_ed_move_cursor
			jz .no_cur_mov
			cmp dword[new_lin],0 ;если есть добавочные строки, то курсор еще не двигаем
			jg .no_cur_mov
			cmp dword[new_spc],0 ;если нет добавочных пробелов, то курсор тоже не двигаем
			jg .no_cur_mov
				inc ted_cur_x ;move cursor
				;call ted_go_to_pos
				cmp byte [esi],13
				jne .no_cur_mov
					mov ted_cur_x,0
					inc ted_cur_y
					;увеличиваем линии в скроллинге на число добавленных в тексте строк
					mov ecx,ted_scr_w
					inc dword[ecx+sb_offs_max_area] ;увеличиваем размер вертикального скроллинга
			.no_cur_mov:

			; *** вставка текущего символа из строки ***
			mov ecx,ted_opt_ed_change_time
			not ecx
			and dword[add_opt],ecx ;n_tim=false;

			mov cl,byte [esi] ;tex[i].c=ta[ns];
			mov byte [edx],cl
			m2m dword [edx+10],ted_tim_ch ;tex[i].tc=ted_tim_ch;
			mov [edx+2],eax ;tex[i].perv=po_t;

			mov ecx,eax
			imul ecx,sizeof.symbol
			add ecx,ted_tex ; *** ecx = tex[po_t] ***
			add ecx,6   ; *** ecx = tex[po_t].next ***
			m2m dword [edx+6],dword [ecx] ;tex[i].next=tex[po_t].next;

			call ted_get_text_arr_index ;*** eax = i ***
			mov [ecx],eax ;tex[po_t].next=i; // ссылки перенаправляем
			mov ecx,[edx+6] ; *** ecx = tex[i].next ***
			imul ecx,sizeof.symbol
			add ecx,ted_tex ; *** ecx = tex[tex[i].next] ***
			mov [ecx+2],eax ;tex[tex[i].next].perv=i;

			; *** вставка дополнительных строк и пробелов
			; если курсор во время вставки находился за текстом ***
			cmp dword[new_lin],0 ;add lines or text
			jle .spc_add
				dec dword[new_lin]
				mov byte [edx],13
				jmp .u1f
			.spc_add:
			cmp dword[new_spc],0 ;add spaces or text
			jle .tex_add
				dec dword[new_spc]
				mov byte [edx],' '
				jmp .u1f
			.tex_add:
			inc esi ; переход к следующему вставляемому символу
			dec ebx
		.u1f:
		add edx,sizeof.symbol
		cmp edx,ted_tex_end
		jge @f ;out of memory
		cmp ebx,0
		jne .beg_cycle
		mov ted_ptr_free_symb,edx ;меняем указатель на свободный символ, для более быстрого поиска памяти
		jmp .add_all
	@@:
	cmp ted_increase_size,0
	je .add_all
		call ted_memory_increase
		cmp ebx,0
		jne .beg_cycle
	.add_all: ;все символы добавлены

	call ted_text_colored
	.no_add:
	popad
	ret
endp

;input:
;  edx = pointer to sumbol, when insert
;  edi = pointer to tedit struct
;output:
;  edx = new pointer to sumbol, when insert
align 4
proc ted_memory_increase
	cmp ted_increase_size,0
	je @f
		push eax ebx ecx
		mov ecx,ted_increase_size
		add ecx,ted_max_chars
		mov ted_max_chars,ecx
		imul ecx,sizeof.symbol
		invoke mem.realloc, ted_tex,ecx
		mov ebx,ted_tex
		mov ted_tex,eax
		mov ted_tex_1,eax
		add ted_tex_1,sizeof.symbol
			sub edx,ebx
			add edx,eax
			mov ted_ptr_free_symb,edx
		add eax,ecx
		mov ted_tex_end,eax
		pop ecx ebx eax
	@@:
	ret
endp

;input:
;  ecx = position to free insert cell
;  edx = pointer to sumbol, when insert
;  esi = added symbol
;  edi = pointer to tedit struct
;output:
;  ecx = position to inserted cell
align 4
ted_char_add:

  .loop_b:
    cmp ecx,ted_tex_end
    jge .end_f
    cmp dword[ecx+10],0
    jne @f
      cmp dword[ecx+14],0
      je .loop_e
    @@:
    add ecx,sizeof.symbol
    jmp .loop_b
  .loop_e:

  push eax ebx
  mov eax,ted_tim_ch
  mov dword[ecx+10],eax
  mov ax,si
  mov byte[ecx],al

  call ted_get_text_arr_index ; *** eax=pos ***
  mov [ecx+2],eax ;tex[i].perv=pos;
  m2m dword[ecx+6],dword[edx+6] ;tex[i].next=tex[pos].next;

  push edx
    mov edx,ecx
    call ted_get_text_arr_index ; *** eax=i ***
  pop edx

  mov [edx+6],eax ;tex[pos].next=i; // ссылки перенаправляем
  mov ebx,[ecx+6]
  ConvertIndexToPointer ebx
  mov [ebx+2],eax ;tex[tex[i].next].perv=i; // ...
  pop ebx eax

  .end_f:
  call ted_text_colored
  ret

;description:
; функция для смены кодировок
;input:
; table - таблица для перекодировки
align 4
proc ted_but_convert_by_table uses eax edx edi esi, edit:dword, table:dword
	mov edi,dword[edit]
	mov esi,dword[table]
	mov edx,ted_tex
	.cycle:
		;переходим на следующий символ
		mov edx,dword[edx+6]
		cmp edx,1
		jle .end_text
		imul edx,sizeof.symbol
		add edx,ted_tex

		movzx eax,byte[edx]
		add eax,esi
		mov al,byte[eax]
		cmp al,0
		je @f
			mov byte[edx],al ;меняем кодировку символа
		@@:
		jmp .cycle
	.end_text:
	;cmp esi,0
	;je @f
		stdcall ted_draw,edi ;обновляем окно
	;@@:
	ret
endp

;input:
; edi = pointer to tedit struct
;output:
; esi = count converted symbols
;description:
; Функция используется для смены регистра выбранных символов
align 4
proc ted_convert_sel_text, conv_fun:dword
  locals
    conv_cou dd ?
  endl
  mov dword[conv_cou],0
  pushad

  call ted_is_select
  cmp al,0
  je .end_f
    call ted_set_undo
    call ted_sel_normalize

    mov esi,ted_seln_x0
    mov ecx,ted_seln_y0
    call ted_get_pos_by_coords
    mov eax,edx
    mov esi,ted_seln_x1
    mov ecx,ted_seln_y1
    call ted_get_pos_by_coords
    ;call ted_get_text_perv_pos
    mov ebx,edx

    cmp eax,ebx
    je .end_f

    inc ted_tim_ch
    mov edx,eax ;i=p0;
    mov ecx,ted_ptr_free_symb
    @@:
      push eax
      mov al,byte[edx]
      call dword[conv_fun] ;преобразование символа
      mov esi,eax
      cmp byte[edx],al
      pop eax
      je .no_change
	m2m dword [edx+14],ted_tim_ch
	call ted_char_add ;b_pos=ted_char_add(tex[i].c^32,i,false,b_pos);
	call ted_get_text_next_pos ;go to added symbol
	inc dword[conv_cou]
      .no_change:

      call ted_iterat_next
      cmp edx,ted_tex
      je @f 
      cmp edx,ebx
      je @f

      jmp @b
    @@:
    cmp dword[conv_cou],0
    jne @f
      dec ted_tim_ch
    @@:
  .end_f:
  popad
  mov esi,dword[conv_cou]
  ret
endp

;output:
; bl = 0 - no delete
; bl = 1 - delete
align 4
proc ted_text_del, edit:dword, del_opt:dword
  push cx edx edi
  mov edi,dword[edit]
  mov ebx,dword[del_opt]

  xor cl,cl
  test ebx,ted_opt_ed_move_cursor
  jz @f
    call ted_cur_move_left
    cmp dl,0
    je .no_del
  @@:
  call ted_get_pos_by_cursor
  cmp ted_gp_opt,1
  je .no_del
    test ebx,ted_opt_ed_change_time
    jz @f
      inc ted_tim_ch
    @@:
    m2m dword [edx+14], ted_tim_ch
    mov cl,1
  .no_del:
  mov bl,cl
  pop edi edx cx
  ret
endp

;input:
; edi = pointer to tedit struct
;output:
; al = 1 if delete
;description:
; Функция удаляет выделенный текст
align 4
proc ted_sel_text_del, del_opt:dword
	push ebx ecx edx esi

	call ted_is_select
	cmp al,0
	je .end_f

		call ted_sel_normalize

		mov esi,ted_seln_x1
		mov ecx,ted_seln_y1
		call ted_get_pos_by_coords
		mov ebx,edx

		mov esi,ted_seln_x0
		mov ecx,ted_seln_y0
		call ted_get_pos_by_coords

		test dword[del_opt],ted_opt_ed_change_time
		jz @f
			inc ted_tim_ch
		@@:
		cmp edx,ted_tex
		je @f
		cmp edx,ebx ;if(i==te)break;
		je @f
			m2m dword[edx+14],ted_tim_ch
			mov esi,ted_opt_ed_change_time
			not esi
			and dword[del_opt],esi ;n_tim=false;
			call ted_iterat_next
			jmp @b
		@@:
		test dword[del_opt],ted_opt_ed_change_time
		jz @f
			dec ted_tim_ch
			xor al,al
		@@:
		test dword[del_opt],ted_opt_ed_change_time
		jnz @f
			mov ecx,ted_seln_x0
			mov edx,ted_seln_y0
			call ted_go_to_pos
			mov ted_sel_x0,0
			mov ted_sel_y0,0
			mov ted_sel_x1,0
			mov ted_sel_y1,0
		@@:
	.end_f:
	pop esi edx ecx ebx
	ret
endp


;input:
; eax = pointer to begin select
; ebx = pointer to end select
; edi = pointer to tedit struct
align 4
ted_revers:
  cmp eax,ebx
  jne @f
    ret
  @@:

  push ecx edx

  mov edx,ted_tex_1
  cmp edx,ebx ;if(p1==1)p1=tex[1].perv;
  jne @f
    call ted_get_text_perv_pos
    mov ebx,edx
  @@:

  push esi
    mov edx,[eax+2] ; *** edx = tex[p0].perv ***
    ConvertIndexToPointer edx
    add edx,6
    mov ecx,[edx] ;tmp = tex[tex[p0].perv].next;

    mov esi,[ebx+6] ; *** esi = tex[p1].next ***
    ConvertIndexToPointer esi
    add esi,2
    m2m dword[edx],dword[esi] ;tex[tex[p0].perv].next = tex[tex[p1].next].perv;

    mov [esi],ecx ;tex[tex[p1].next].perv = tmp;
  pop esi

  mov ecx,[eax+2] ;tmp = tex[p0].perv;
  m2m dword[eax+2],dword[ebx+6] ;tex[p0].perv = tex[p1].next;
  mov [ebx+6],ecx ;tex[p1].next = tmp;

  mov edx,eax ;i=p0;
  @@:
    mov ecx,[edx+6] ;tmp = tex[i].next;
    m2m dword[edx+6],dword[edx+2] ;tex[i].next = tex[i].perv;
    mov [edx+2],ecx ;tex[i].perv = tmp;
    cmp edx,ebx ;if(i==p1)break;
    je @f
; ---
;cmp edx,ted_tex
;je @f
; ---
    mov edx,ecx ;i = tmp;
    ConvertIndexToPointer edx
    jmp @b
  @@:
  pop edx ecx
  call ted_text_colored
  ret


;input:
; edi = pointer to tedit struct
;output:
; dl = 0 not move
; dl = 2 if move up
; dl = 8 if scroll move up
align 4
ted_cur_move_up:
  cmp ted_cur_y,0
  je @f
    dec ted_cur_y
    mov dl,2
    ret
  @@:
  push eax
  mov eax,ted_scr_w
  cmp dword[eax+sb_offs_position],0
  je @f
    dec dword[eax+sb_offs_position]
    mov dl,8
    jmp .ret_f
  @@:
  mov dl,0
  .ret_f:
  pop eax
  ret

;input:
; edi = pointer to tedit struct
;output:
; dl = 0 not move
; dl = 2 if move down
; dl = 8 if scroll move down
align 4
ted_cur_move_down:
  push eax ebx
  mov ebx,ted_scr_w
  mov dl,0
  mov eax,dword[ebx+sb_offs_cur_area]
  dec eax
  cmp ted_cur_y,eax
  jge @f
    inc ted_cur_y
    mov dl,2
    jmp .ret_f
  @@:
  mov eax,ted_cur_y
  add eax,dword[ebx+sb_offs_position]
  inc eax
  cmp dword[ebx+sb_offs_max_area],eax
  jle @f
    inc dword[ebx+sb_offs_position]
    mov dl,8
  @@:
  .ret_f:
  pop ebx eax
  ret


;input:
; edi = pointer to tedit struct
;output:
; dl = 0 not move
; dl = 1 if move up
align 4
ted_cur_move_page_up:
  push eax ebx
  mov ebx,ted_scr_w
  mov eax,dword[ebx+sb_offs_cur_area]
  xor dl,dl
  cmp eax,dword[ebx+sb_offs_position]
  jg @f
    sub dword[ebx+sb_offs_position],eax
    mov dl,1
  @@:
  cmp dword[ebx+sb_offs_position],0
  je @f
  cmp dl,1
  je @f
    mov dword[ebx+sb_offs_position],0
    mov dl,1
  @@:
  pop ebx eax
  ret

;input:
; edi = pointer to tedit struct
align 4
ted_cur_move_page_down:
	push eax ebx ecx
	mov ecx,ted_scr_w

	xor dl,dl
	mov eax,dword[ecx+sb_offs_max_area]
	sub eax,dword[ecx+sb_offs_cur_area]
	cmp dword[ecx+sb_offs_position],eax
	jge @f
		mov ebx,dword[ecx+sb_offs_cur_area]
		add dword[ecx+sb_offs_position],ebx
		mov dl,1
		mov dword[ecx+sb_offs_redraw],1
		cmp dword[ecx+sb_offs_position],eax
		jle @f
			mov dword[ecx+sb_offs_position],eax
	@@:
	pop ecx ebx eax
	ret

;input:
; edi = pointer to tedit struct
;output:
; dl = 0 not move
; dl = 1 if move left
; dl = 3 if move left and up
; dl = 8 if scroll move up
align 4
ted_cur_move_left:
	cmp ted_cur_x,0
	je @f
		dec ted_cur_x
		mov dl,1
		ret
	@@:
	push eax
	mov eax,ted_scr_h
	cmp dword[eax+sb_offs_position],0
	je @f
		dec dword[eax+sb_offs_position]
		mov dl,8
		jmp .ret_f
	@@:
	cmp ted_cur_y,0
	jne @f
		mov eax,ted_scr_w
		mov dl,0
		cmp dword[eax+sb_offs_position],0
		je .ret_f
			dec dword[eax+sb_offs_position]
			call ted_scroll_set_redraw
			call ted_cur_move_x_last_char
			mov dl,8
			jmp .ret_f
	@@:
	cmp ted_cur_y,0
	je @f
		dec ted_cur_y
		call ted_cur_move_x_last_char
		cmp dl,8
		je .ret_f
		mov dl,3
		jmp .ret_f
	@@:
	mov dl,0
	.ret_f:
	pop eax
	ret

;input:
; edi = pointer to tedit struct
align 4
ted_cur_move_right:
	push eax ebx
	mov eax,ted_scr_h
	xor dl,dl
	mov ebx,dword[eax+sb_offs_cur_area]
	cmp ted_cur_x,ebx
	jge @f
		inc ted_cur_x
		mov dl,1
		jmp .ret_f
	@@:
		inc dword[eax+sb_offs_position]
		mov dl,8
	.ret_f:
	pop ebx eax
	ret

;input:
; edi = pointer to tedit struct
align 4
ted_cur_move_x_last_char:
;[hScr.position]
;[hScr.cur_area]
;dl-???
  push eax ebx ecx
  mov eax,ted_cur_y
  mov ecx,ted_scr_w
  add eax,dword[ecx+sb_offs_position]
  call ted_strlen
  xor dl,dl

  mov ecx,ted_scr_h
  cmp ebx,dword[ecx+sb_offs_position]
  jge @f
    mov dl,8
    mov dword[ecx+sb_offs_position],ebx
  @@:
  sub ebx,dword[ecx+sb_offs_position]

  cmp ebx,dword[ecx+sb_offs_cur_area]
  jle @f ; b---[---]---e
    add dword[ecx+sb_offs_position],ebx
    mov ebx,dword[ecx+sb_offs_cur_area]
    sub dword[ecx+sb_offs_position],ebx
    mov dl,8
  @@:
  mov ted_cur_x,ebx
  pop ecx ebx eax
  ret

;input:
; edi = pointer to tedit struct
;output:
; dl = 0 not move
; dl = 1 move cursor
; dl = 8 move cursor and scroll
align 4
ted_cur_move_x_first_char:
	xor dl,dl
	cmp ted_cur_x,0
	je @f
		mov ted_cur_x,0
		mov dl,1
	@@:
	push eax
	mov eax,ted_scr_h
	cmp dword[eax+sb_offs_position],0
	je @f
		mov dword[eax+sb_offs_position],0
		mov dl,8
	@@:
	pop eax
	ret

;input:
; edx = pointer to symbol struct
; edi = pointer to tedit struct
;output:
; eax = array index
align 4
ted_get_text_arr_index:
	push ecx edx
		mov eax,edx
		sub eax,ted_tex
		xor edx,edx
		mov ecx,sizeof.symbol
		div ecx
	pop edx ecx
	ret

;input:
; edx = pointer to symbol struct
; edi = pointer to tedit struct
;output:
; edx = pointer to 'perv' struct
align 4
ted_get_text_perv_pos:
	mov edx,dword[edx+2]
	imul edx,sizeof.symbol
	add edx,ted_tex
	ret

;input:
; edx = pointer to symbol struct
;output:
; edx = pointer to 'next' symbol struct
align 4
ted_get_text_next_pos:
	mov edx,dword[edx+6]
	imul edx,sizeof.symbol
	add edx,ted_tex
	ret

;input:
; edi = pointer to tedit struct
;output:
; edx = symbol under cursor
; ted_gp_opt = 1,2
; edx = tex[1].perv if error
; ted_gp_opt = 0
align 4
ted_get_pos_by_cursor:
	push eax ecx esi
		mov esi,ted_cur_x
		mov eax,ted_scr_h
		add esi,dword[eax+sb_offs_position]
		mov ecx,ted_cur_y
		mov eax,ted_scr_w
		add ecx,dword[eax+sb_offs_position]
		call ted_get_pos_by_coords
	pop esi ecx eax
	ret

;input:
; esi = XPos
; ecx = YPos
; edi = pointer to tedit struct
;output:
; edx = symbol under cursor
; ted_gp_opt = 1 if found text line
; ted_gp_opt = 2 if found text line and column
; edx = tex[1] if error
; ted_gp_opt = 0 if text no found
align 4
ted_get_pos_by_coords:
  push eax ;Row
  push ebx ;Col

  xor eax,eax
  xor ebx,ebx
  mov ted_gp_opt,0
  mov edx,ted_tex
  @@:
    call ted_iterat_next
    cmp edx,ted_tex_1
    jle @f 
    cmp ebx,esi
    jne .u1_0 ;Col <> ted_cur_x
      mov ted_gp_opt,1
      cmp eax,ecx
      jge @f ; Row >= ted_cur_y
    .u1_0:
    mov ted_gp_opt,0
    inc ebx
    cmp byte [edx],13
    jne @b
    cmp eax,ecx
    jge @f ; Row >= ted_cur_y
    inc eax
    xor ebx,ebx
    jmp @b
  @@:
  cmp eax,ecx
  jne @f ; Row = ted_cur_y
    inc ted_gp_opt
  @@:
  cmp ted_gp_opt,0
  jne @f
    mov edx,ted_tex_1
    ;call ted_get_text_perv_pos
  @@:
  pop ebx eax
  ret


;input:
; eax = Row
; edi = pointer to tedit struct
;output:
; ebx = str len
align 4
ted_strlen:
  push edx ecx
  ;ecx = Row, from cycle

  xor ebx,ebx
  xor ecx,ecx
  mov edx,ted_tex
  @@:
    call ted_iterat_next
    cmp edx,ted_tex_1
    jle @f 
    inc ebx
    cmp byte [edx],13
    jne @b
    dec ebx ;lenght minus 1 sumbol to paragraph
    cmp eax,ecx
    je @f
    xor ebx,ebx
    inc ecx
    jmp @b
  @@:

  cmp eax,ecx
  je @f
    xor ebx,ebx
  @@:

  pop ecx edx
  ret


;input:
; edx = symbol position
; edi = pointer to tedit struct
;output:
; eax = number of line
; ebx = symbol position in line
align 4
ted_get_text_coords:
  push edx
  xor eax,eax
  xor ebx,ebx
  @@:
    call ted_iterat_perv

    cmp eax,0
    jne .no_col_mov
    inc ebx
    .no_col_mov:

    cmp edx,ted_tex_1
    jle @f
    cmp byte [edx],13
    jne @b
    inc eax
    jmp @b
  @@:
  dec ebx
  pop edx
  ret

;input:
; edi = pointer to tedit struct
;output:
; eax = num lines
align 4
ted_get_num_lines:
  push edx
  mov eax,1
  mov edx,ted_tex
  @@:
    call ted_iterat_next
    cmp edx,ted_tex_1
    jle @f
    cmp byte [edx],13
    jne @b
    inc eax
    jmp @b
  @@:
;...
;dec eax
  pop edx
  ret


;input:
; edi = pointer to tedit struct
;description:
; отменяет отмененные действия, перед изменением документа
align 4
proc ted_set_undo
	mov ted_drag_k,0 ;заканчиваем выделение от клавиатуры
	cmp ted_tim_undo,1
	jl .no_work

	push eax ebx edx
	mov edx,ted_tex
	call ted_get_text_next_pos ;long i=tex[0].next;
	mov eax,ted_tim_undo
	sub ted_tim_ch,eax ;ted_tim_ch-=ted_tim_undo;
	mov eax,ted_tim_ch
	cmp ted_tim_ls,eax ;if(ted_tim_ls>ted_tim_ch)
	jle @f
		mov ted_tim_ls,0
	@@:
		cmp edx,ted_tex_1
		jle @f

		;if(tex[i].tc>ted_tim_ch){ // если создание символа было отменено
		cmp [edx+10],eax
		jle .no_u1
			mov dword [edx+10],0
			mov dword [edx+14],0

			mov ebx,[edx+2]
			imul ebx,sizeof.symbol
			add ebx,ted_tex ;ebx=tex[i].perv
			m2m dword [ebx+6],dword [edx+6] ;tex[tex[i].perv].next=tex[i].next;

			mov ebx,[edx+6]
			imul ebx,sizeof.symbol
			add ebx,ted_tex ;ebx=tex[i].next
			m2m dword [ebx+2],dword [edx+2] ;tex[tex[i].next].perv=tex[i].perv;

			cmp ted_ptr_free_symb,edx
			jle .no_cor_free
				mov ted_ptr_free_symb,edx ;меняем указатель на свободный символ, для более быстрого поиска памяти
			.no_cor_free:
			mov edx,ebx ;оптимизируем по скорости (edx после вызова ted_get_text_next_pos будет равен ebx)
			jmp @b
		.no_u1:

		;else if(tex[i].td>ted_tim_ch) tex[i].td=0; // если удаление символа было отменено
		cmp [edx+14],eax
		jle .no_u2
			mov dword [edx+14],0
		.no_u2:

		call ted_get_text_next_pos
		jmp @b
	@@:
	mov ted_tim_undo,0
	mov eax,ted_tim_co
	cmp ted_tim_ch,eax
	jge @f
		mov ted_tim_co,0
	@@:
	pop edx ebx eax
	.no_work:
	ret
endp

;input:
; ecx = Col
; edx = Row
; edi = pointer to tedit struct
align 4
ted_go_to_pos:
	push eax
	mov eax,ted_scr_w
	mov ted_cur_x,ecx
	sub edx,dword[eax+sb_offs_position]

	cmp edx,dword[eax+sb_offs_cur_area] ;ted_cur_y > [.cur_area]
	jl @f
		push ebx
		mov ebx,edx
		sub ebx,dword[eax+sb_offs_cur_area]
		inc ebx
		add dword[eax+sb_offs_position],ebx
		sub edx,ebx
		pop ebx
		; ??? redrav
	@@:
	mov ted_cur_y,edx
	pop eax
	ret

;input:
; edi = pointer to tedit struct
align 4
ted_text_colored:
  push eax edx
  mov eax,ted_tim_ch
  sub eax,ted_tim_undo
  mov ted_tim_co,eax
  mov edx,ted_tex
  @@:
    call ted_iterat_next
    cmp edx,ted_tex_1
    jle @f
    mov byte[edx+1],0
    jmp @b
  @@:

  cmp ted_key_words_count,1
  jl .no_colors
  mov edx,ted_tex
  @@:
    call ted_text_find_sel_color
    cmp edx,ted_tex_1
    jle .no_colors
    jmp @b
  .no_colors:
  pop edx eax
  ret


;input:
; edx = pointer to start symbol
; edi = pointer to tedit struct
;output:
; edx = pointer to next symbol
;description:
; Функция для поиска и выделения подсвеченых слов
align 4
proc ted_text_find_sel_color
locals
  begPos dd ? ;начальная позиция
  endPos dd ? ;конечная позиция
  find db ? ;найдено / не найдено
  f_color db ? ;индекс цвета найденого слова
endl
  push eax ebx ecx esi
;eax = word_n текущий номер (позиция) проверяемого слова в списке
;ebx = для разных целей
;ecx = l_pos последний номер (позиция) подходящего слова в списке
;esi = для разных целей, номер проверяемого символа в слове
  mov dword[begPos],1
  mov dword[endPos],1
  mov byte[find],0
  mov byte[f_color],1
  @@:
    call ted_iterat_next
    cmp edx,ted_tex_1
    jle @f

    xor eax,eax
    mov al,byte[edx]
    shl ax,2 ;eax*=4
    add eax,ted_arr_key_pos
    mov eax,dword[eax]
    cmp eax,0
    jl @b ;if( (word_n=ted_arr_key_pos[(unsigned char)tex[i].c])>-1 ){

    mov ecx,eax
    ;while(l_pos<ted_key_words_count && Col[l_pos].Text[0]==Col[word_n].Text[0])
    .wh_1b:
      cmp ecx,ted_key_words_count
      jge .wh_1e
      ColToIndexOffset ecx,esi
      mov bl,byte[esi]
      ColToIndexOffset eax,esi
      cmp bl,byte[esi]
      jne .wh_1e
	inc ecx
      jmp .wh_1b
    .wh_1e:

    mov dword[begPos],edx ;bP=i;
    mov esi,1

    .wh_2b: ;while(1){
      call ted_iterat_next

      ;while(l_pos>word_n && Col[l_pos-1].Text[pos]!=tex[i].c)
      .wh_3b:
	cmp ecx,eax
	jle .wh_3e
	dec ecx
	ColToIndexOffset ecx,ebx
	inc ecx
	;cmp byte[ebx+esi],byte[edx]
	mov bl,byte[ebx+esi]
	cmp bl,byte[edx]
	je .wh_3e
	  dec ecx
	jmp .wh_3b
      .wh_3e:

      ColToIndexOffset eax,ebx
      cmp byte[ebx+esi],0
      jne .if_0 ;if(Col[word_n].Text[pos]==0){
	mov dword[endPos],edx ;eP=i;
	ColToIndexOffset eax,ebx
	mov bl,byte[ebx+MAX_COLOR_WORD_LEN+7]
	mov byte[f_color],bl ;f_color=Col[word_n].color;

mov byte[find],1
	  ColToIndexOffset eax,ebx ;... ebx = Col[word_n]
	  mov bl,byte[ebx+MAX_COLOR_WORD_LEN+4]
	  cmp bl,0 ;if(Col[word_n].wwo)
	  je .if_2n
	    push edx
	    mov edx,dword[begPos]
     call ted_iterat_perv

	    btr bx,0 ;1-1
	    jae .if_3e ;if(Col[word_n].wwo&1)
	      ;u1= !(isalnum(cont_s)||cont_s=='_')
	      call isalnum
	      jae .if_3e
		mov byte[find],0
	    .if_3e:

	    btr bx,3 ;4-1
	    jae .if_4e ;if(Col[word_n].wwo&8)
	      ;u1= !isalpha(cont_s);
	      call isalpha
	      jae .if_4e
		mov byte[find],0
	    .if_4e:

	    mov edx,dword[endPos]
;     call ted_iterat_next

	    btr bx,1 ;2-1
	    jae .if_5e ;if(Col[word_n].wwo&2)
	      ;u1= !(isalnum(cont_s)||cont_s=='_')
	      call isalnum
	      jae .if_5e
		mov byte[find],0
	    .if_5e:

	    btr bx,4 ;5-1
	    jae .if_6e ;if(Col[word_n].wwo&16)
	      ;u1= !isalpha(cont_s);
	      call isalpha
	      jae .if_6e
		mov byte[find],0
	    .if_6e:

	    btr bx,2 ;3-1
	    jae .if_7e ;if(Col[word_n].wwo&4)
	    ColToIndexOffset eax,ebx
	    mov bx,word[ebx+MAX_COLOR_WORD_LEN+5]
	    call ted_iterat_next_pos_char
       cmp edx,ted_tex_1
       jle .if_7e
       mov dword[endPos],edx
	    .if_7e:

	    pop edx
	  .if_2n:
;                 if(i!=1){ // не конец документа
;                   cont_s=tex[eP].c;
;                   if(Col[word_n].wwo&2) u2= !(isalnum(cont_s)||cont_s=='_');  // не букв.-числ. символ
;                   if(u2 && Col[word_n].wwo&16) u2= !isalpha(cont_s); // не числ. символ
;                   if(Col[word_n].wwo&4) eP=ted_iterat_next_pos_char(eP,Col[word_n].endc);

	cmp eax,ecx
	je .wh_2e ;if(word_n==l_pos) break; // do double - если слово точно последнее
      .if_0:

      cmp edx,ted_tex_1
      jle .wh_2e ;if(i==1) break;

      ;while(l_pos>word_n && Col[word_n].Text[pos]!=tex[i].c)
      .wh_4b:
	cmp ecx,eax
	jle .wh_4e
	ColToIndexOffset eax,ebx
	;cmp byte[ebx+esi],byte[edx]
	mov bl,byte[ebx+esi]
	cmp bl,byte[edx]
	je .wh_4e
	  inc eax
	jmp .wh_4b
      .wh_4e:

      cmp eax,ecx
      je .wh_2e;if(word_n==l_pos) break;
      inc esi ;pos++;
      jmp .wh_2b
    .wh_2e:

    cmp byte[find],1 ;if(fnd)break;
    je @f
    mov edx,dword[begPos];i=bP;
    jmp @b
  @@:

  cmp byte[find],1
  jne .if_1e ;if(fnd){ // выделение найденого текста
;    if(!mode_sf1 || (mode_sf1 && strlen(Col[word_n].f1->c_str())>0)){
    mov eax,dword[begPos]
    mov bl,byte[f_color]
    mov byte[eax+1],bl ;tex[bP].col=f_color;
    mov eax,dword[endPos]
    mov byte[eax+1],0xff ;tex[eP].col=255;
;    return ItPoPerv(eP); // возвращаем позицию конца вхождения
    mov edx,dword[endPos]
    call ted_get_text_perv_pos
    jmp @f
  .if_1e:
    mov edx,ted_tex
  @@:

  pop esi ecx ebx eax
  ret
endp

;input:
; edx = pointer to char (byte)
;output:
; cf=1 if symbol is...
align 4
tab_all_num db 0,0,0,0,0,0,11111111b,11b,11111110b,0xff,0xff,111b,11111110b,0xff,0xff,111b,0,0,0,0,0,0,0,0;,0,0,0,0,0,0,0,0 - tab_alpha_0,0,0,0,0,0,0,0
tab_alpha db 0,0,0,0,0,0,0,0,11111110b,0xff,0xff,111b,11111110b,0xff,0xff,111b,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

align 4
isalnum:
  push eax ebx
  mov al,byte[edx] ;al=offset
  shr al,3
  and eax,11111b
  lea ebx,[tab_all_num]
  add ebx,eax
  mov ah,byte[ebx]
  mov al,byte[edx] ;al=bit
  and ax,111b
  mov bx,word[ebx]
  btr bx,ax
  pop ebx eax
  ret
align 4
isalpha:
  push eax ebx
  mov al,byte[edx] ;al=offset
  shr al,3
  and eax,11111b
  lea ebx,[tab_alpha]
  add ebx,eax
  mov ah,byte[ebx]
  mov al,byte[edx] ;al=bit
  and ax,111b
  mov bx,word[ebx]
  btr bx,ax
  pop ebx eax
  ret

align 4
proc ted_show_help_f1, edit:dword
  push eax edx edi
  mov edi,dword[edit]

  call ted_get_pos_by_cursor
  push edx
    call ted_iterat_next_color_tag
    mov eax,edx
  pop edx
  call ted_iterat_perv_color_tag

  cmp eax,ted_tex
  jle @f
  cmp edx,ted_tex_1
  jle @f
    stdcall ted_find_help_id,eax
  @@:
  ;call ted_draw_main_cursor
  call ted_draw_help_f1
  pop edi edx eax
  ret 
endp

;input:
; edx = position begin 'symbol' struct
; edi = pointer to tedit struct
; end_pos = position end 'symbol' struct
align 4
proc ted_find_help_id, end_pos:dword
; ecx = word_n
; ebx = l_pos
  mov ted_help_id,-1

  push ebx ecx
    xor ebx,ebx
    mov bl,byte[edx]
    shl bx,2 ;ebx*=4
    add ebx,ted_arr_key_pos
    mov ecx,dword[ebx]
    cmp ecx,0
    jl .if_0e ;if( (word_n=ted_arr_key_pos[(unsigned char)tf[0]])>-1 ){
      push esi eax
      mov ebx,ecx ;l_pos=word_n;
      ColToIndexOffset ecx,esi
      push cx
      mov cl,byte[esi]
      @@:
	cmp ebx,ted_key_words_count ;while(l_pos<ted_key_words_count)
	jge @f
	;ColToIndexOffset ecx,esi
	ColToIndexOffset ebx,eax
	cmp cl,byte[eax] ;&& Col[l_pos].Text[0]==Col[word_n].Text[0])
	jne @f
	  inc ebx ;l_pos++;
	  jmp @b
      @@:
      pop cx
      call ted_iterat_next ;pos=1;
      mov esi,1
      @@:
	push dx
	push word[edx]
	pop dx 
	  .wh_0b:
	    cmp ebx,ecx ;while(l_pos>word_n
	    jle .wh_0e
	    dec ebx
	    ColToIndexOffset ebx,eax
	    inc ebx
	    cmp byte[eax+esi],dl ;&& Col[l_pos-1].Text[pos]!=tf[i])
	    je .wh_0e
	      dec ebx ;l_pos--;
	    jmp .wh_0b
	  .wh_0e:

	  .wh_1b:
	    cmp ebx,ecx ;while(l_pos>word_n
	    jle .wh_1e
	    ColToIndexOffset ecx,eax
	    cmp byte[eax+esi],dl
	    je .wh_1e
	      inc ecx ;word_n++;
	    jmp .wh_1b
	  .wh_1e:
	pop dx

	cmp ecx,ebx ;if(word_n==l_pos) break;
	je @f
	call ted_iterat_next ;pos++;
	cmp edx,dword[end_pos] ;for(...;i<strlen;...)
	je @f ;jge
	inc esi
	jmp @b
      @@:
      pop eax esi

      mov ted_help_id,ecx
      ;return word_n;

    .if_0e:
  pop ecx ebx
  ret
endp

;output:
; eax = код ошибки
; ebx = колличество прочитанных байт
align 4
proc ted_open_file, edit:dword, file:dword, f_name:dword ;функция открытия файла
	push ecx edx edi
	mov edi,dword[edit]

	; *** проверяем размер памяти и если не хватает то увеличиваем ***
	;пробуем получить информацию о файле
	mov eax,70
	mov ebx,dword[file]
	mov dword[ebx], 5
	mov dword[ebx+4], 0
	mov dword[ebx+8], 0
	mov dword[ebx+12], 0
	m2m dword[ebx+16], ted_tex
	mov  byte[ebx+20], 0
	push dword[f_name]
	pop dword[ebx+21]
	int 0x40
	cmp eax,0
	je .end_0
		mov edx,ted_max_chars
		cmp eax,2 ;функция не поддерживается для данной файловой системы
		je @f
		jmp .ret_f
	.end_0:
	;проверяем хватит ли памяти для загрузки файла
	mov ecx,ted_max_chars
	sub ecx,2 ;ecx = максимальное число байт, для которых была выделена память
	mov edx,ted_tex
	mov edx,dword[edx+32] ;+32 = +0x20: qword: размер файла в байтах
	cmp edx,ecx
	jl @f
		;увеличиваем память если не хватило
		mov ecx,edx ;память необходимая для открытия файла
		add ecx,2  ;память для служебных начального и конечного символов
		add ecx,ted_increase_size ;память для редактирования файла
		mov ted_max_chars,ecx
		imul ecx,sizeof.symbol
		invoke mem.realloc, ted_tex,ecx
		mov ted_tex,eax
		mov ted_tex_1,eax
		add ted_tex_1,sizeof.symbol
		add eax,ecx
		mov ted_tex_end,eax
		mov ecx,ted_tex_1
		add ecx,sizeof.symbol
		mov ted_ptr_free_symb,ecx
	@@:

	; *** пробуем открыть файл ***
	mov eax,70
	mov ebx,dword[file]
	mov dword[ebx], 0
	mov dword[ebx+4], 0
	mov dword[ebx+8], 0
	m2m dword[ebx+12], edx ;число байт, которые могут быть считаны с файла (не больше чем ted_max_chars)
	m2m dword[ebx+16], ted_tex
	mov  byte[ebx+20], 0
	push dword[f_name]
	pop dword[ebx+21]
	int 0x40

	cmp eax,0
	je @f
	cmp eax,6
	je @f
		jmp .ret_f
	@@:
	cmp ebx,-1
	je .ret_f
		;if open file
		call ted_on_open_file
	.ret_f:
	pop edi edx ecx
	ret
endp

align 4
proc ted_but_select_word, edit:dword
	pushad
	mov edi,dword[edit]

	call ted_get_pos_by_cursor
	push edx
		call ted_iterat_perv_color_tag
		cmp edx,ted_tex_1
		jle @f
			call ted_get_text_coords
			mov ted_sel_x0,ebx
			mov ted_sel_y0,eax
		@@:
	pop edx
	call ted_iterat_next_color_tag
	cmp edx,ted_tex_1
	jle @f
		call ted_get_text_coords
		mov ted_sel_x1,ebx
		mov ted_sel_y1,eax
	@@:

	cmp ted_fun_draw_panel_buttons,0
	je @f
		call ted_fun_draw_panel_buttons
	@@:
	stdcall ted_draw,edi
	popad
	ret
endp

align 4
proc ted_but_cut, edit:dword
	push edi
	mov edi,dword[edit]

	stdcall ted_but_copy,edi
	call ted_set_undo
	stdcall ted_sel_text_del,ted_opt_ed_change_time

	cmp al,1
	jne @f
		stdcall ted_draw,edi
		cmp ted_fun_draw_panel_buttons,0
		je @f
			call ted_fun_draw_panel_buttons
	@@:
	pop edi
	ret
endp

;output:
; al = 1 if copy text
align 4
proc ted_but_copy, edit:dword
	pushad
	mov edi,dword[edit]

	call ted_is_select
	cmp al,0
	je .end_f ;if not selected text
	call ted_sel_normalize

	mov esi,ted_seln_x1
	mov ecx,ted_seln_y1
	call ted_get_pos_by_coords
	mov ebx,edx
	mov esi,ted_seln_x0
	mov ecx,ted_seln_y0
	call ted_get_pos_by_coords
	mov esi,ebx

	mov ecx,12 ;system buffer header size
	mov ebx,ted_buffer
	mov dword[ebx+4],0 ;text data
	mov dword[ebx+8],1 ;code 866
	add ebx,ecx
	@@:
		cmp edx,ted_tex_1 ;end of file
		jle @f
		cmp edx,esi ;end of select
		je @f
		inc ecx
		cmp ecx,ted_buffer_size ;owerflow bufer
		je @f

		mov al,byte[edx]
		mov byte[ebx],al
		inc ebx

		call ted_iterat_next
		jmp @b
	@@:
	mov byte[ebx],0

	cmp ecx,12
	je .end_f
		inc ecx ;размер данных в буфере + символ завершения строки
		mov ebx,ted_buffer
		mov dword[ebx],ecx
		mcall 54,2,ecx,ted_buffer
		call ted_draw_buffer
		cmp ted_fun_draw_panel_buttons,0
		je .end_f
			call ted_fun_draw_panel_buttons
	.end_f:
	popad
	ret
endp


align 4
proc ted_but_paste, edit:dword
	pushad
	mov edi,dword[edit]

	mcall 54,0
	cmp eax,1
	jl .no_buf_r

	mov esi,eax
	.cycle: ;обратный цикл по слотам
	dec esi ;номер текущего, проверяемого слота
	mcall 54,1,esi ;read system buffer
	cmp eax,1
	je .no_buf_r
	cmp eax,-1
	je .no_buf_r
		mov ecx,dword[eax]
		cmp ecx,1 ;size
		jl .no_buf_r
		cmp dword[eax+4],0 ;text
		je @f
			cmp esi,1
			jge .cycle ;если в буфере не текст, а слотов в буфере несколько, пробуем перейти к верхнему слоту
			jmp .no_buf_r
		@@:
		cmp dword[eax+8],1 ;866
		je @f
			cmp esi,1
			jge .cycle ;если в буфере текст не в кодировке 866 ... пробуем перейти к верхнему слоту
			jmp .no_buf_r
		@@:
		;копирование текста из системного буфера во внутренний
		cmp ecx,ted_buffer_size
		jle @f
			mov ecx,ted_buffer_size
		@@:
		mov edi,ted_buffer
		mov esi,eax
		add	esi,4 ;12
		mov dword[edi],ecx
		add edi,4 ;12
		sub ecx,4 ;12
		rep movsb
		mov edi,dword[edit]

		mov esi,eax
		add	esi,12
		jmp .buf_r
	.no_buf_r:
		
	;если не удалось прочитать данные из системного буфера, попадаем сюда
	mov esi,ted_buffer
	cmp dword[esi],1 ;проверяем есть ли данные во внутреннем буфере
	jl .no_paste ;если вообще ничего не удалось прочитать идем на выход
	add esi,12 ;system buffer header size
	.buf_r:
	
	mov edx,esi
	call tl_strlen
	cmp eax,1
	jl .no_paste
		mov esi,eax
		call ted_set_undo
		mov ebx,ted_opt_ed_change_time+ted_opt_ed_move_cursor
		stdcall ted_sel_text_del,ebx
		cmp al,1
		jne .del
			mov ebx,ted_opt_ed_move_cursor
		.del:
		stdcall ted_text_add,edi,edx,esi,ebx
		stdcall ted_draw,edi
		cmp ted_fun_draw_panel_buttons,0
		je .no_paste
			call ted_fun_draw_panel_buttons
	.no_paste:
	popad
	ret
endp

align 4
proc ted_but_sumb_upper uses edi esi, edit:dword
	mov edi,dword[edit]

	stdcall ted_convert_sel_text,fb_char_toupper
	cmp esi,0
	je @f
		stdcall ted_draw,edi
	@@:
	ret
endp

align 4
proc ted_but_sumb_lover uses edi esi, edit:dword
	mov edi,dword[edit]

	stdcall ted_convert_sel_text,fb_char_todown
	cmp esi,0
	je @f
		stdcall ted_draw,edi
	@@:
	ret
endp

align 4
proc ted_but_reverse, edit:dword
  push eax ebx edi
  mov edi,dword[edit]

  call ted_is_select
  cmp al,0
  je @f
    call ted_sel_normalize
    push esi ecx edx
      mov esi,ted_seln_x0
      mov ecx,ted_seln_y0
      call ted_get_pos_by_coords
      mov eax,edx
      mov esi,ted_seln_x1
      cmp esi,0
      je .beg_str
	dec esi
      .beg_str:
      mov ecx,ted_seln_y1
      call ted_get_pos_by_coords
      ;call ted_get_text_perv_pos
      mov ebx,edx
    pop edx ecx esi
    ;cmp eax,...
    ;je @f
    call ted_revers
  @@:
  stdcall ted_draw,edi
  pop edi ebx eax
  ret
endp

align 4
proc ted_but_undo, edit:dword
	push eax edi
	mov edi,dword[edit]

	mov eax,ted_tim_undo
	cmp ted_tim_ch,eax
	jbe @f
		inc ted_tim_undo
		;call ted_text_colored
		stdcall ted_draw,edi
		cmp ted_fun_draw_panel_buttons,0
		je @f
			call ted_fun_draw_panel_buttons
	@@:
	pop edi eax
	ret
endp

align 4
proc ted_but_redo, edit:dword
	push edi
	mov edi,dword[edit]

	cmp ted_tim_undo,1
	jb @f
		dec ted_tim_undo
		;call ted_text_colored
		stdcall ted_draw,edi
		cmp ted_fun_draw_panel_buttons,0
		je @f
			call ted_fun_draw_panel_buttons
	@@:
	pop edi
	ret
endp

align 4
proc ted_but_find_next, edit:dword
	pushad
	mov edi,dword[edit]

	call ted_get_pos_by_cursor
	mov eax,ted_buffer_find
	mov bl,byte[eax]
	@@:
		call ted_get_find_rezult
		cmp bh,1
		je @f ; find
			call ted_iterat_next
			cmp edx,ted_tex_1
			jle @f
			jmp @b
	@@:
	cmp bh,0
	je @f
		call ted_get_text_coords
		inc ebx ;move cursor right
		mov ted_sel_x1,ebx
		mov ted_sel_y1,eax
		mov edx,eax
		mov ecx,ebx
		call ted_go_to_pos
		mov edx,esi ;esi было установлео в ted_get_find_rezult
		call ted_get_text_coords
		mov ted_sel_x0,ebx
		mov ted_sel_y0,eax
		stdcall ted_draw,edi
		jmp .end_find
	@@:
		;попадаем сюда если текст не найден
		cmp ted_fun_find_err,0
		je .end_find
			call ted_fun_find_err ;пользовательская функция
	.end_find:
	popad
	ret
endp

;input:
; edi = pointer to tedit struct
align 4
ted_key_ctrl_home:
	mov ted_cur_x,0
	mov ted_cur_y,0
	push eax
		mov eax,ted_scr_w
		mov dword[eax+sb_offs_position],0
		mov eax,ted_scr_h
		mov dword[eax+sb_offs_position],0
	pop eax
	stdcall ted_draw,edi
	cmp ted_fun_draw_panel_buttons,0
	je @f
		call ted_fun_draw_panel_buttons
	@@:
	ret

;input:
; edi = pointer to tedit struct
align 4
proc ted_sel_key_up
  cmp ted_drag_k,1
  je @f
    call ted_sel_start
    mov ted_drag_k,1
  @@:
  push dx
    call ted_cur_move_up
    cmp dl,8
    jne @f
      call ted_scroll_set_redraw
    @@:
  pop dx
  call ted_sel_move
  stdcall ted_draw,edi
  ret
endp

;input:
; edi = pointer to tedit struct
align 4
proc ted_sel_key_down
  cmp ted_drag_k,1
  je @f
    call ted_sel_start
    mov ted_drag_k,1
  @@:
  push dx
    call ted_cur_move_down
    cmp dl,8
    jne @f
      call ted_scroll_set_redraw
    @@:
  pop dx
  call ted_sel_move
  stdcall ted_draw,edi
  ret
endp

;input:
; edi = pointer to tedit struct
align 4
proc ted_sel_key_left
  cmp ted_drag_k,1
  je @f
    call ted_sel_start
  @@:
  push dx
    call ted_cur_move_left
    call ted_sel_move
    cmp ted_drag_k,1
    je @f
      mov ted_drag_k,1
      mov dl,8
    @@:
    cmp dl,8
    jne @f
      call ted_scroll_set_redraw
      stdcall ted_draw,edi
      jmp .end_f
    @@:
      stdcall ted_draw_cur_line,edi
    .end_f:
  pop dx
  ret
endp

;input:
; edi = pointer to tedit struct
align 4
proc ted_sel_key_right
  cmp ted_drag_k,1
  je @f
    call ted_sel_start
  @@:
  push dx
    call ted_cur_move_right
    call ted_sel_move
    cmp ted_drag_k,1
    je @f
      mov ted_drag_k,1
      mov dl,8
    @@:
    cmp dl,8
    jne @f
      call ted_scroll_set_redraw
      stdcall ted_draw,edi
      jmp .end_f
    @@:
      stdcall ted_draw_cur_line,edi
    .end_f:
  pop dx
  ret
endp

;input:
; edi = pointer to tedit struct
;description:
; this function need to optimize output
align 4
proc ted_draw_cursor_sumb
  pushad

  mov eax,13 ;rect
  mov ebx,ted_wnd_l
  add ebx,ted_rec_l
  mov edx,ted_cur_x
  imul edx,ted_rec_w
  add ebx,edx
  shl ebx,16
  add ebx,ted_rec_w

  mov ecx,ted_wnd_t ;calc rect -> y0,y1
  add ecx,ted_rec_t
  mov edx,ted_cur_y
  imul edx,ted_rec_h
  add ecx,edx
  shl ecx,16
  add ecx,ted_rec_h

  mov edx,ted_color_wnd_work
  push ecx
    call ted_sel_normalize

    mov esi,ted_scr_w
	mov ecx,dword[esi+sb_offs_position]
    sub ted_seln_y0,ecx
    sub ted_seln_y1,ecx

    mov ecx,ted_cur_y
    cmp ecx,ted_seln_y0
    jl .no_cur_sel
    cmp ecx,ted_seln_y1
    jg .no_cur_sel
    mov edx,ted_color_select ;меняем цвет фона на цвет выделения
    
    mov esi,ted_scr_h
	cmp ecx,ted_seln_y0
    jne @f
      mov ecx,ted_cur_x
      add ecx,dword[esi+sb_offs_position]
      cmp ecx,ted_seln_x0
      jge @f
      mov edx,ted_color_wnd_work
    @@:

    mov ecx,ted_cur_y
    cmp ecx,ted_seln_y1
    jne .no_cur_sel
      mov ecx,ted_cur_x
      add ecx,dword[esi+sb_offs_position]
      cmp ecx,ted_seln_x1
      jl .no_cur_sel
      mov edx,ted_color_wnd_work

    .no_cur_sel:
  pop ecx
  int 0x40 ;рисование прямоугольника

  call ted_get_pos_by_cursor ;берем позицию символа
  cmp ted_gp_opt,2
  jne @f
    mov eax,4
    mov esi,1
    ror ecx,16
    mov bx,cx
    add ebx,0x10001
    call ted_get_symb_color
    call ted_convert_invis_symb
    int 0x40 ;рисование символа
  @@:

  popad
  ret
endp

;input:
; edx -> pointer to text
; edi -> указатель на структуру tedit
;output:
; ecx = color
; if ted_mode_color=0 then ecx=ted_color_wnd_text
align 4
ted_get_symb_color:
  mov ecx,ted_color_wnd_text ;задаем цвет текста по умолчанию

  push eax edx
  cmp ted_mode_color,0
  je .exit
    jmp .on_first
    @@:
      call ted_iterat_perv
      cmp edx,ted_tex_1
      jle .exit
    .on_first:
      xor eax,eax
      mov al,byte[edx+1]
      cmp al,0 ;если al=0 то цвет не меняется
    je @b

    cmp eax,ted_colors_text_count
    jge .exit

    shl ax,2 ;умножаем индекс цвета на 4 байта
    mov ecx,ted_text_colors ;прибавляем смещение 1-го цвета
    add ecx,eax
    mov ecx,dword[ecx] ;устанавливаем текущий цвет текста по смещению
  .exit:
  pop edx eax
  ret

;input:
; edx = pointer to text
; edi = pointer to tedit struct
;description:
; Функция преобразует невидимые символы в печатаемые на экране
align 4
ted_convert_invis_symb:
	cmp ted_mode_invis,1
	jne .end_f
		cmp byte[edx],9
		jne @f
			lea edx,[ted_symbol_tab]
		@@:
		cmp byte[edx],13
		jne @f
			mov edx,edi
			add edx,ted_offs_symbol_new_line
		@@:
	.end_f:
	ret

;input:
; edi = pointer to tedit struct
align 4
ted_scroll_set_redraw:
	push eax
	mov eax,ted_scr_w
	mov dword[eax+sb_offs_redraw],1
	mov eax,ted_scr_h
	mov dword[eax+sb_offs_redraw],1
	pop eax
	ret

align 4
proc ted_draw, edit:dword
	locals
		line_num dd ?
	endl
	pushad
	mov edi,dword[edit]

	mov eax,4 ;draw text
	mov ecx,ted_text_colors
	mov ecx,dword[ecx]

	mov ebx,ted_wnd_l
	add ebx,ted_rec_l
	shl ebx,16
	add ebx,ted_wnd_t
	add ebx,ted_rec_t
	add ebx,0x10001 ;добавляем отступы для выравнивания буквы по центру

	call ted_sel_normalize ;need before draw select
	mov esi,ted_scr_w
	mov esi,dword[esi+sb_offs_position]
	mov dword[line_num],esi

	stdcall ted_clear_line_before_draw, edi,ebx,1,esi
	call ted_get_first_visible_pos
	cmp edx,0
	je .no_draw_text
	mov esi,1 ;длинна выводимого текста по 1-му символу
	@@:
		call ted_iterat_next
		cmp edx,ted_tex_1
		jle .no_draw_text

		; *** цветовая разметка
		cmp ted_mode_color,0
		je .no_col_change
		cmp byte[edx+1],0
		je .no_col_change
			call ted_get_symb_color
		.no_col_change:

		cmp byte [edx],13
		jne .no_13
			cmp ted_mode_invis,1
			jne .no_invis
				push edx
				mov edx,edi
				add edx,ted_offs_symbol_new_line
				int 0x40
				pop edx
			.no_invis:
			add ebx,ted_rec_h
			;optimized output \/
			mov eax,ted_wnd_h
			add eax,ted_wnd_t
			cmp bx,ax
			jg .no_draw_text
			mov eax,4
			;optimized output /\        
			and ebx,0xffff
			ror ebx,16
			add ebx,ted_wnd_l
			add ebx,ted_rec_l
			inc ebx
			ror ebx,16
			inc dword[line_num] ;increment line number
			stdcall ted_clear_line_before_draw,edi,ebx,1,dword[line_num]
			call ted_opt_draw_line_left
			jmp @b
		.no_13:

		int 0x40
		ror ebx,16
		add ebx,ted_rec_w
		mov esi,ted_wnd_l
		add esi,ted_wnd_w
		cmp bx,si
		jl .no_opt
			call ted_opt_draw_line_right
		.no_opt:
		mov si,1
		ror ebx,16
		jmp @b
	.no_draw_text:

	stdcall ted_clear_line_before_draw,edi,ebx,0,dword[line_num]
	call ted_draw_line_numbers
	call ted_draw_main_cursor

;---------------------------------------------
; set all_redraw flag for draw all ScrollBar
; In some cases it is necessity to draw only the area
; of moving of a "runner", for acceleration of output - 
; in this case the flag needs to be reset to 0 (zero).
	mov eax,ted_scr_h
	mov esi,ted_scr_w
	mov dword[eax+sb_offs_all_redraw],1
	mov dword[esi+sb_offs_all_redraw],1

; рисование полос прокрутки
	stdcall scroll_bar_horizontal.draw,eax ;[scrollbar_hor_draw]
	stdcall scroll_bar_vertical.draw,esi ;[scrollbar_ver_draw]
; reset all_redraw flag 
	mov dword[eax+sb_offs_all_redraw],0
	mov dword[esi+sb_offs_all_redraw],0
;---------------------------------------------

  ;left-bottom square
  mov ebx,ted_wnd_l
  shl ebx,16
  add ebx,ted_rec_l
  mov ecx,ted_wnd_t
  add ecx,ted_wnd_h
  shl ecx,16
  mov cx,word[eax+sb_offs_size_y]
  inc cx
  mov edx,ted_color_wnd_capt ;[sc.work]
  mov eax,13
  int 0x40

	;right-bottom square
	mov ebx,ted_wnd_l
	add ebx,ted_wnd_w
	shl ebx,16
	mov bx,word[esi+sb_offs_size_x]
	inc bx
	int 0x40

	cmp ted_fun_draw_panel_find,0
	je @f
		call ted_fun_draw_panel_find
	@@:
	cmp ted_fun_draw_panel_syntax,0
	je @f
		call ted_fun_draw_panel_syntax
	@@:
	popad
	ret
endp

;input:
; edi = pointer to tedit struct
align 4
proc ted_draw_main_cursor
  pushad

  mov eax,13 ;draw cursor
  mov ecx,ted_wnd_t ;calc rect -> y0,y1
  add ecx,ted_rec_t
  mov edx,ted_cur_y
  imul edx,ted_rec_h
  add ecx,edx

  cmp ted_cur_ins,1 ;проверка режима работы курсора (обычный или вставка)
  jne @f
    mov edx,ted_rec_h
    inc edx   ;1->1, 3->2, 5->3, ...
    shr edx,1 ;edx = высота строки деленная на 2 (когда курсор не полный)
    add ecx,edx
  @@:
  shl ecx,16
  add ecx,ted_rec_h
  cmp ted_cur_ins,1
  jne @f
    shr cx,1 ;делим высоту курсора на 2
  @@:

  mov ebx,ted_wnd_l ;calc rect -> x0,x1
  add ebx,ted_rec_l
  mov edx,ted_cur_x
  imul edx,ted_rec_w
  add ebx,edx
  shl ebx,16
  add ebx,ted_rec_w

  mov edx,ted_color_cursor
  int 0x40 ;вывод курсора

  call ted_get_pos_by_cursor
  cmp ted_gp_opt,2
  jne @f
    mov eax,4 ;draw text
    mov esi,1
    ror ecx,16
    mov bx,cx
    add ebx,0x10001
    cmp ted_cur_ins,1
    jne .no_up_tetx
      mov ecx,ted_rec_h
      inc cx ; 1->1, 3->2, 5->3, ...
      shr cx,1
      sub bx,cx
    .no_up_tetx:
    mov ecx,ted_color_cur_text
    call ted_convert_invis_symb
    int 0x40
  @@:

  mov eax,4
  mov ebx,ted_wnd_l
  add ebx,ted_rec_l
  shl ebx,16
  add ebx,ted_wnd_t
  add ebx,3
  mov ecx,ted_color_wnd_bord
  or  ecx,0x80000000
  lea edx,[txtRow]
  int 0x40 ;вывод подписи 'Строка'

  add ebx,0x500000
  lea edx,[txtCol]
  int 0x40 ;вывод подписи 'Знак'

  cmp ted_tim_undo,0
  je @f
    add ebx,0x500000
    lea edx,[txtOtm]
    int 0x40
    sub ebx,0x500000
  @@:

  call ted_draw_buffer
  call ted_draw_help_f1

  mov eax,47 ;draw cursor coords
  mov esi,ted_color_wnd_bord
  or  esi,0x40000000

  mov edx,ebx
  ror edx,16
  sub edx,35
  ror edx,16
  ;add edx,3
  mov ebx,0x40000 ;Row=...
  mov ecx,ted_scr_w
  mov ecx,dword[ecx+sb_offs_position]
  add ecx,ted_cur_y
  inc ecx

push edi
  mov edi,ted_color_wnd_work
  int 0x40 ;вывод числа текущей строки
pop edi

  ;mov ebx,0x40000 ;Col=...
  mov ecx,ted_scr_h
  mov ecx,dword[ecx+sb_offs_position]
  add ecx,ted_cur_x
  inc ecx
  add edx,0x500000
push edi
  mov edi,ted_color_wnd_work
  int 0x40 ;вывод числа знаков
pop edi

  cmp ted_tim_undo,0
  je @f
    mov ecx,ted_tim_undo
    add edx,0x500000
	mov edi,ted_color_wnd_work ;портим регистр edi, но в конце функции это уже не важно
    int 0x40 ;вывод числа отмененных действий
  @@:

  popad
  ret
endp

;input:
; edi = pointer to tedit struct
proc ted_draw_buffer
	pushad

	mov eax,ted_buffer
	cmp dword[eax],1 ;смотрим размер буфера
	jl @f
		mov ebx,ted_rec_l
		add bx,300
		cmp ebx,ted_wnd_w ;сравниваем координату для вывод текста
		jge @f ;подпись не влазит в окно

		add ebx,ted_wnd_l
		shl ebx,16
		add ebx,ted_wnd_t
		add ebx,3
		mov ecx,ted_color_wnd_bord
		or ecx,0x40000000

		mov edx,ted_buffer
		add edx,12
		mov esi,edx
		mov edi,ted_color_wnd_work ;edi - destroy not pointer to tedit
		call tl_strlen
		;cmp eax,0 ;буфер пуст
		;je @f
		cmp eax,20
		jle .crop_buf
			mov eax,20 ;обрезка подписи до 20 символов
		.crop_buf:
		mov esi,eax
		mov eax,4
		int 0x40 ;вывод содержимого буфера

		sub ebx,50 shl 16
		lea edx,[txtBuf]
		mov esi,edx
		call tl_strlen
		mov esi,eax
		mov eax,4
		xor ecx,0x40000000 ;убираем цвет фона
		int 0x40 ;вывод подписи для буфера
	@@:
	popad
	ret
endp

;input:
; edi = pointer to tedit struct
align 4
proc ted_draw_help_f1
	pushad
	cmp ted_rec_t,13 ;минимальная высота для рисования справки
	jle @f
		mov eax,13 ;clear place before draw help
		mov ebx,ted_wnd_l
		add ebx,ted_rec_l
		shl ebx,16
		add ebx,ted_wnd_w
		sub ebx,ted_rec_l
		mov ecx,ted_wnd_t
		add ecx,13
		shl ecx,16
		add ecx,ted_rec_h
		mov edx,ted_color_wnd_capt
		int 0x40

	cmp ted_help_id,-1
	je @f
		mov eax,ted_help_id
		ColToIndexOffset eax,edx

		;SetCoordinates
		mov ebx,ted_wnd_l
		add ebx,ted_rec_l
		shl ebx,16
		add ebx,ted_wnd_t
		add ebx,13 ;=3+10

		;SetTextColor
		xor eax,eax
		mov al,byte[edx+MAX_COLOR_WORD_LEN+7]
		shl ax,2
		mov ecx,ted_text_colors
		add ecx,eax
		mov ecx,dword[ecx]
		or	ecx,0xc0000000 ;SetTextStyles
		mov esi,edi
			mov edi,ted_color_wnd_work
			mov eax,4
			int 0x40
		mov edi,esi

		;*** draw help string ***
		mov ecx,ted_color_wnd_bord
		or ecx,0x80000000
		mov edx,dword[edx+MAX_COLOR_WORD_LEN]
		cmp edx,0
		je @f
			add edx,ted_help_text_f1
			add ebx,0x500000
			int 0x40
	@@:
	popad
	ret
endp

;input:
; edi = pointer to tedit struct
align 4
proc ted_draw_line_numbers
  pushad

  ;top panel with caption
  mov ebx,ted_wnd_l
;  add ebx,ted_rec_l
  shl ebx,16
  add ebx,ted_wnd_w
;  sub ebx,ted_rec_l
  mov edx,ted_color_wnd_work
  mov ecx,ted_wnd_t
  shl ecx,16
  add ecx,ted_rec_t
  mov eax,13
  mov edx,ted_color_wnd_capt
  int 0x40

  ;line numbers
  mov ebx,0x40000 ;format
  mov ecx,ted_scr_w
  mov ecx,dword[ecx+sb_offs_position]
  inc ecx
  mov edx,3
  add edx,ted_wnd_l
  rol edx,16
  add edx,ted_wnd_t
  add edx,ted_rec_t
  @@:

push ebx ecx edx
  ;left panel with numbers
  mov ebx,ted_wnd_l
  shl ebx,16
  add ebx,ted_rec_l
  mov ecx,ted_rec_h
  rol ecx,16
  mov cx,dx
  rol ecx,16
  mov eax,13
  mov edx,ted_color_wnd_capt
  int 0x40 ;рисуем прямоугольник под номером строки
pop edx ecx ebx

    mov eax,47
    mov esi,ted_color_wnd_bord
    int 0x40 ;рисуем номер строки
    inc ecx
    add edx,ted_rec_h
    sub edx,ted_wnd_t
	mov esi,edx
	and esi,0xffff
    cmp esi,ted_wnd_h
    jge @f
    add edx,ted_wnd_t
    jmp @b
  @@:

  popad
  ret
endp

;output:
; ah = symbol
align 4
proc KeyConvertToASCII, table:dword
	push ebx
	mov ebx,dword[table] ;convert scan to ascii
	ror ax,8
	xor ah,ah
	add bx,ax ;? ebx,eax
	mov ah,byte[ebx]
	pop ebx
	ret
endp

align 4
proc ted_draw_cur_line, edit:dword
  pushad
    mov edi,dword[edit]

    mov ebx,ted_wnd_l
    add ebx,ted_rec_l
    shl ebx,16
    mov eax,ted_cur_y
    imul eax,ted_rec_h
	mov bx,ax
    add ebx,ted_wnd_t
    add ebx,ted_rec_t ;ebx - координаты для прямоугольника очистки линии
	add ebx,0x10001   ;добавляем отступы для выравнивания буквы по центру

    call ted_sel_normalize ;need before draw select
	mov ecx,ted_cur_y
	mov eax,ted_scr_w
    add ecx,dword[eax+sb_offs_position]
    stdcall ted_clear_line_before_draw,edi,ebx,1,ecx

    mov eax,ted_scr_h
	mov esi,dword[eax+sb_offs_position]
    call ted_get_pos_by_coords

  cmp ted_gp_opt,2
  jne .no_draw_text
;  mov eax,4 ;draw text
  call ted_get_symb_color
  mov esi,1 ;draw 1 symbol
  @@:
    ;call ted_iterat_next
    cmp edx,ted_tex_1
    jle .no_draw_text

    ; *** цветовая разметка
    cmp ted_mode_color,0
    je .no_col_change
    cmp byte[edx+1],0
    je .no_col_change
      call ted_get_symb_color
    .no_col_change:

    mov eax,4 ;draw text
    cmp byte [edx],13
    jne .no_13
      cmp ted_mode_invis,1
      jne .no_draw_text
 push edx
 mov edx,edi
 add edx,ted_offs_symbol_new_line
 int 0x40
 pop edx
      jmp .no_draw_text
    .no_13:

    int 0x40
    ror ebx,16
    add ebx,ted_rec_w
    mov eax,ted_wnd_w
    add eax,ted_wnd_l ;ax = отступ по оси x
    cmp bx,ax
    jge .no_draw_text ;Opt
    ror ebx,16
    call ted_iterat_next
    jmp @b
  .no_draw_text:

  call ted_draw_main_cursor
  popad
  ret
endp

;input:
; eax - text need find
; bl - first symbol to find
; edx - first symbol pointer
; edi - pointer to tedit struct
;output:
; bh - rezult
; edx - last text position (if find sucess)
; esi - first symbol pointer
;description:
; Функция проверяет совпадает ли текст в буфере eax
; с текстом редактора по указателю edx.
; Стандартные функции (напр. strcmp) тут не подойдут, потому что
; в памяти редактора текст содержится не в виде ascii строк.
align 4
ted_get_find_rezult:
  push eax
    mov bh,1
    mov esi,edx ;copy edx
    @@:
      cmp byte[edx],bl
      jne .no_text

      inc eax ;*** get next symbol (in find text) ***
      mov bl,byte[eax]
      cmp bl,0
      je @f ;end of find text

      call ted_iterat_next ;*** get next symbol (in editor text) ***
      cmp edx,ted_tex_1
      jle @f ;end of editor text

      jmp @b
      .no_text:
	xor bh,bh
	mov edx,esi ;restore edx
    @@:
  pop eax
  mov bl,byte[eax] ;restore bl
  ret

;input:
;  clear_o - если =1 очистить одну строку, =0 очистить все строки окна до низу
align 4
proc ted_clear_line_before_draw, edit:dword, coords:dword, clear_o:dword, numb_lin:dword
	pushad
	mov edi,dword[edit]
	mov ebx,dword[coords]	;ebx = x*2^16+y coords to left up point clear line
	mov esi,dword[numb_lin] ;esi - number text line

	sub ebx,0x10001 ;отнимаем отступы для выравнивания буквы по центру
	cmp dword[clear_o],0
	jne @f
		add ebx,ted_rec_h
		inc esi
		ror ebx,16
		xor bx,bx
		add ebx,ted_wnd_l
		add ebx,ted_rec_l ;bx = ted_wnd_l+ted_rec_l
		ror ebx,16
	@@:

	mov eax,ted_wnd_h
	add eax,ted_wnd_t
	cmp ax,bx
	jl .no_clear
	sub ax,bx

	mov cx,bx
	shl ecx,16

	xor bx,bx
	add ebx,ted_wnd_w
	sub ebx,ted_rec_l
	xor cx,cx
	add ecx,ted_rec_h
	mov edx,ted_color_wnd_work

	cmp dword[clear_o],0
	je .pusto
	cmp ax,cx
	jge @f
	.pusto:
		mov cx,ax
	@@:

	call ted_is_select
	cmp al,0
	je @f
	cmp ted_seln_y0,esi
	jg @f
	cmp ted_seln_y1,esi
	jl @f
		mov edx,ted_color_select ;draw selected line
	@@:

	mov eax,13 ;rect
	int 0x40

	call ted_is_select
	cmp al,0
	je .no_clear

	mov al,13 ;rect
	xor cx,cx
	add ecx,ted_rec_h
	cmp ted_seln_y0,esi
	jne @f
		push bx esi
		mov edx,ted_seln_x0 ; верхняя полоса (затирает слева)
		mov esi,ted_scr_h
		cmp edx,dword[esi+sb_offs_position]
		jle .in_wnd
			sub edx,dword[esi+sb_offs_position]
			imul edx,ted_rec_w
			mov bx,dx
			jmp .no_wnd
		.in_wnd:
		mov bx,0
		.no_wnd:
		mov edx,ted_color_wnd_work
		int 0x40
		pop esi bx
	@@:
	cmp ted_seln_y1,esi
	jne @f
		push esi
		mov edx,ted_seln_x1 ; нижняя полоса (затирает справа)
		mov esi,ted_scr_h
		cmp edx,dword[esi+sb_offs_position]
		jle .in_wnd2
			sub edx,dword[esi+sb_offs_position]
			imul edx,ted_rec_w
			sub bx,dx
			shl edx,16
			add ebx,edx
		.in_wnd2:

		mov edx,ted_color_wnd_work
		int 0x40
		pop esi
	@@:

	.no_clear:
	popad
	ret
endp

;input:
; edi = pointer to tedit struct
;output:
; ecx = новый цвет символа
; edx = pointer to symbol
; edx = 0 if text not in screen
align 4
ted_get_first_visible_pos:
	push eax ecx
	mov eax,ted_scr_w
	mov edx,ted_tex
	xor ecx,ecx
	@@:
		cmp ecx,dword[eax+sb_offs_position]
		je @f
		call ted_iterat_next
		cmp edx,ted_tex_1
		jle @f
		cmp byte [edx],13
		jne @b
		inc ecx
		jmp @b
	@@:

	cmp ecx,dword[eax+sb_offs_position]
	je @f
		xor edx,edx
	@@:
	cmp ecx,dword[eax+sb_offs_max_area]
	jle @f
		mov dword[eax+sb_offs_max_area],ecx
	@@:
	pop ecx eax
	call ted_opt_draw_line_left
	ret

;input:
; edx = pointer to symbol
; edi = pointer to tedit struct
;output:
; ecx = цвет символа
; edx = указатель на первый левый символ
;description:
; функция нужна для оптимизации вывода текста
align 4
proc ted_opt_draw_line_left
  push ebx

  mov ebx,ted_scr_h
  mov ebx,dword[ebx+sb_offs_position]
  cmp ebx,0
  je .ret_f
  push eax
  mov eax,edx

  cmp edx,ted_tex
  jne @f
    call ted_iterat_next
    jmp .beg_cycle
  @@:

  cmp ebx,0
  je @f

  cmp byte[edx],13
  jne @f
    call ted_iterat_next
    .beg_cycle:
  @@:
    cmp edx,ted_tex_1
    jle @f
    cmp byte[edx],13
    je @f
    cmp ebx,0
    je @f
;--------------------------------------
xor eax,eax ;eax будет меняться
mov al,byte[edx+1]
cmp al,0
je .no_color
cmp eax,ted_colors_text_count
jge .no_color
  xor ecx,ecx
  mov cl,byte[edx+1]
  shl cx,2
  add ecx,ted_text_colors
  mov ecx,dword[ecx]
.no_color:
;--------------------------------------
    mov eax,edx
    call ted_iterat_next
    dec ebx
    jmp @b
  @@:
    mov edx,eax
  pop eax
  .ret_f:
  call ted_get_symb_color
  pop ebx
  ret
endp

;input:
; edx = pointer to symbol
; edi = pointer to tedit struct
;output:
; ecx = symbol color
; edx = pointer to 13 symbol
;description:
; функция нужна для оптимизации вывода текста
align 4
proc ted_opt_draw_line_right
	push eax
	mov eax,edx
	@@:
		cmp edx,ted_tex_1
		jle @f
		cmp byte[edx],13
		je @f
		mov eax,edx
		call ted_iterat_next
		jmp @b
	@@:
	mov edx,eax ;perv sumbol
	call ted_get_symb_color

	pop eax
	ret
endp

align 4
proc ted_mouse, edit:dword
	pushad
	mov edi,dword[edit]

	;обрабатываем скроллинги
	mov edx,ted_scr_h
	mov ecx,ted_scr_w

	cmp word[edx+sb_offs_delta2],0
	jne .horizontal

	mov eax,dword[ecx+sb_offs_max_area]
	cmp eax,dword[ecx+sb_offs_cur_area]
	jbe .horizontal
	; mouse event for Vertical ScrollBar
	stdcall scroll_bar_vertical.mouse,ecx ;[scrollbar_ver_mouse]
	cmp dword[ecx+sb_offs_redraw],0
	je @f
		mov dword[ecx+sb_offs_redraw],0
		stdcall ted_draw,edi
		jmp .no_in_wnd
	@@:
	cmp word[ecx+sb_offs_delta2],0
	jne .no_in_wnd
	.horizontal:
	mov eax,dword[edx+sb_offs_max_area]
	cmp eax,dword[edx+sb_offs_cur_area]
	jbe .other
	; mouse event for Horizontal ScrollBar
	stdcall scroll_bar_horizontal.mouse,edx ;[scrollbar_hor_mouse]
	cmp dword[edx+sb_offs_redraw],0
	je .other
		mov dword[edx+sb_offs_redraw],0
		stdcall ted_draw,edi
		jmp .no_in_wnd
	.other:
	cmp word[ecx+sb_offs_delta2],0
	jne .no_in_wnd
	cmp word[edx+sb_offs_delta2],0
	jne .no_in_wnd

	;обрабатываем окно редактора
	mcall 37,2 ;get mouse buttons
	cmp al,1
	jne @f
		mcall 37,1 ;get mouse coords
		mov ebx,ted_wnd_t
		add ebx,ted_rec_t
		cmp ax,bx
		jl @f ;y_mouse<y_wnd

		sub ebx,ted_rec_t
		add ebx,ted_wnd_h
		cmp bx,ax
		jl @f ;y_mouse>y_wnd

		mov ebx,ted_wnd_l
		add ebx,ted_rec_l
		mov ecx,eax
		shr ecx,16
		cmp cx,bx
		jl @f ;x_mouse<x_wnd

		sub ebx,ted_rec_l
		add ebx,ted_wnd_w
		cmp bx,cx
		jl @f ;x_mouse>x_wnd

		call ted_draw_cursor_sumb
		call ted_wnd_main_click
		jmp .no_in_wnd
	@@:
	mov edx,ted_el_focus
	cmp dword[edx],edi
	jne @f
		call ted_wnd_main_mouse_scroll ;смотрим на прокрутку колеса мыши
	@@:
	cmp ted_drag_m,0
	je .no_in_wnd
		mov ted_drag_m,0
		stdcall ted_draw,edi
		cmp ted_fun_draw_panel_buttons,0
		je .no_in_wnd
			call ted_fun_draw_panel_buttons
	.no_in_wnd:
	popad
	ret
endp

;input:
; eax -> (x,y)
; edi -> указатель на структуру tedit
;description:
; функция вызывется при нажатии кнопкой мыши и попадении курсором в окно редактора
align 4
ted_wnd_main_click:
	push ebx ecx edx
	mov ebx,ted_el_focus
	mov dword[ebx],edi ;ставим фокус

  push eax
    shr eax,16
    and eax,0xffff
    sub eax,ted_wnd_l
    sub eax,ted_rec_l

    xor edx,edx
    mov ecx,ted_rec_w
    div cx
    ;inc eax
	mov ebx,ted_scr_h
    cmp eax,dword[ebx+sb_offs_cur_area]
    jle @f
      mov eax,dword[ebx+sb_offs_cur_area]
    @@:
    ;dec eax
    mov ted_cur_x,eax
  pop eax

  push eax
    and eax,0xffff
    sub eax,ted_wnd_t
    sub eax,ted_rec_t

    xor edx,edx
    mov ecx,ted_rec_h
    div cx
    inc eax
	mov ebx,ted_scr_w
    cmp eax,dword[ebx+sb_offs_cur_area]
    jle @f
      mov eax,dword[ebx+sb_offs_cur_area]
    @@:
    dec eax
    mov ted_cur_y,eax
  pop eax

	cmp ted_drag_m,0
	je @f
		call ted_sel_move
		jmp .sel_move
	@@:
		mov ted_drag_m,1
		call ted_sel_start
	.sel_move:
	pop edx ecx ebx
	ret

;input:
; edi = pointer to tedit struct
align 4
ted_wnd_main_mouse_scroll:
	push eax ebx ecx
	mcall 37,7 ;прокрутка колеса мыши
	cmp ax,0
	je .no_scroll
		mov ecx,ted_scr_w
		mov ebx,dword[ecx+sb_offs_position] ;copy old scroll position
		and eax,0xffff
		btr ax,15
		jae @f
			or eax,0xffff8000
		@@:
		add dword[ecx+sb_offs_position],eax

		mov eax,[ecx+sb_offs_position]
		cmp eax,[ecx+sb_offs_max_area]
		jb @f
			mov dword[ecx+sb_offs_position],ebx ;if scroll position out of range
			jmp .no_scroll
		@@:
		stdcall ted_draw,edi
	.no_scroll:
	pop ecx ebx eax
	ret

align 4
proc ted_save_file, edit:dword, file:dword, f_name:dword
  pushad
  mov edi,dword[edit]

  stdcall ted_can_save,edi
  cmp al,0
;  je .no_save

  mov ecx,ted_max_chars
  invoke mem.alloc,ecx
  push eax ;запоминаем указатель на выделенную память

  mov edx,ted_tex
  xor ecx,ecx
  @@:
    call ted_iterat_next
    cmp edx,ted_tex_1
    jle @f ;edx = ted_tex or edx = ted_tex+sizeof.symbol
    mov bl,[edx]
    mov byte[eax],bl
    inc eax
    inc ecx
    jmp @b
  @@:

  cmp ecx,0
  je @f
    mov ebx,dword[file]
    pop eax ;записываем указатель на выделенную память
    mov dword[ebx+16],eax
    push eax ;обратно запоминаем указатель на выделенную память
    mov eax,70
    mov dword[ebx], 2
    mov dword[ebx+4], 0
    mov dword[ebx+8], 0
    mov dword[ebx+12], ecx
    mov  byte[ebx+20], 0
    push dword[f_name]
    pop dword[ebx+21]
    int 0x40

    mov ted_err_save,al

    cmp eax,0
    je .no_msg
;    cmp eax,6
;    je @f
      cmp ax,10
      jl .zifra_0_9
	mov al,'?'
	sub ax,48
      .zifra_0_9:
      add ax,48
cmp ted_fun_save_err,0
je @f
call ted_fun_save_err
      jmp @f
    .no_msg:
    m2m ted_tim_ls,ted_tim_ch
  @@:

  pop ecx ;записываем указатель на выделенную память
  invoke mem.free,ecx
  .no_save:
  popad
  ret
endp
}