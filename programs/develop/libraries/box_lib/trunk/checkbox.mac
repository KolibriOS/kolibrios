;файл создан 13.02.2009 <Lrz> На код применена GPL2 лицензия
;Макрос для системной библиотеки box_lib.obj
;Checkbox

ch_struc_size=36
ch_flag_en=10b ;элемент выбран

ch_left  equ [edi]         ;Є®®а¤Ё­ в  ­ з «  аЁб®ў ­Ёп Ї® е
ch_top   equ [edi+2]       ;Є®®а¤Ё­ в  ­ з «  аЁб®ў ­Ёп Ї® г
ch_text_margin equ [edi+4] ;=4 а ббв®п­ЁҐ ®в Їап¬®гЈ®«м­ЁЄ  зҐЄ Ў®Єб  ¤® ­ ¤ЇЁбЁ 
ch_size  equ [edi+8]       ;12 а §¬Ґа Єў ¤а в  зҐЄ Ў®Єб  
ch_color equ [edi+12]      ;жўҐв ў­гваЁ checkbox
ch_border_color equ [edi+16] ; or [edi+4] ;жўҐв а ¬ЄЁ checkbox ҐҐ ¬®¦­® § ¤ вм б ¬®бв®пвҐ«м­®
ch_text_color   equ [edi+20] ;[edi+4]  ;жўҐв вҐЄбв 
ch_text_ptr     equ [edi+24] ;гЄ § вҐ«м ­  ­ з «® вҐЄбв®ў®© бва®ЄЁ 
ch_text_length  equ [edi+28]
ch_flags equ [edi+32]      ;д« ЈЁ 

macro check_boxes_set_sys_color start,end,color_table
{
    mov     edi,start
    mov     ecx,((end-start)/ch_struc_size)
    mov     esi,color_table
@@:
;    push    dword [esi+20] ;жўҐв а Ў®зҐ© ®Ў« бвЁ ®Є­ 
;    pop     dword ch_color
    push    dword [esi+32] ;жўҐв вҐЄбв  ў а Ў®зҐ© ®Ў« бвЁ ®Є­ 
    pop     dword ch_text_color
    push    dword [esi+36] ;жўҐв Ја дЁЄЁ ў ®Є­Ґ (а §¤Ґ«ЁвҐ«м­лҐ «Ё­ЁЁ Ё в.Ї.)
    pop     dword ch_border_color
    add     edi,ch_struc_size
    loop    @b
}
struc check_box left,top,ch_text_margin,ch_size,color,border_color,text_color,text,ch_text_length,flags
{        ;бвагЄвга  Ї а ¬Ґва®ў ¤«п зҐЄ Ў®Єб 
.left: dw left      ;+0 Ї®«®¦Ґ­ЁҐ Ї® е
.top:  dw top       ;+2 Ї®«®¦Ґ­ЁҐ Ї® г
.ch_text_margin:  dd ch_text_margin ;а ббв®п­ЁҐ ®в Їап¬®гЈ®«м­ЁЄ  зҐЄ Ў®Єб  ¤® ­ ¤ЇЁбЁ
.ch_size: dd ch_size ;а §¬Ґа Єў ¤а в  зҐЄ Ў®Єб , ¤«п ЇаЁ¬Ґа  12
.color:   dd color   ;жўҐв ў­гваЁ зҐЄЎ®Єб 
.border_color: dd border_color ;жўҐв а ¬ЄЁ
.text_color:   dd text_color   ;жўҐв ­ ¤ЇЁбЁ
.text: dd text                 ; ¤аҐб ў Є®¤Ґ Їа®Ја ¬¬л Ј¤Ґ а бЇ®«®¦Ґ­ вҐЄбв
.ch_text_length: dd ch_text_length ;¤«Ё­­  бва®ЄЁ б бЁ¬ў®« ¬Ё
.flags: dd flags+0   ; д« ЈЁ        
}

macro use_checkbox_draw
{
check_box_draw:
       pusha   ;сохраним все регистры
       mov     edi,dword [esp+36]
       mov eax,13 
       movzx ebx,word ch_left 
       shl ebx,16 
       add ebx,ch_size 
       mov ecx,ch_top 
       shl ecx,16 
       add ecx,dword ch_size 
       mov edx,dword ch_border_color 
       mcall ;рисуем рамку 

       mov edx,dword ch_color 
       add ebx,1 shl 16 - 2 
       add ecx,1 shl 16 - 2 
       mcall ;закрашиваем внутренности чекбокса 

       test dword ch_flags,2  ;достать значение бита из переменной и поместить в  флаг CF 
       jz   @f                ;в если CF=1, то выполним следующую процедуру иначе перейти на нижнюю @@
       call check_box_draw_ch  ;нарисовать включенный чек бокс
@@:
;----------------------------
;расчет куда будет произведен вывод текста
;----------------------------
        movzx ebx,word ch_left        ;загрузить значение х для чек бокса
        add   ebx,dword ch_size
        add   ebx,dword ch_text_margin;добавить размер стороны и расстояние на котором начнется вывод текста
        shl   ebx,16                ;сдвинем на 16 разрядов в лево (умножим на 65536)
        mov   bx,word ch_top        ;загрузим значение по y
        add   ebx,ch_size
        mov   ecx,dword ch_text_color        ;загрузим цвет надписи + flags
        sub   ebx,7        ;добавим значение длины стороны -9+2
        
        mov   edx,dword ch_text_ptr                ;укажем адрес от куда нужно выводить строку
        mov   esi,dword ch_text_length
        ;внесем в eax значение вывода надписи на канву
        mov   eax,4
        mcall                  ;Вывод 
popa                              ;восстановить значения регистров из стека
ret 4                             ;выйдем из процедуры

check_box_clear_ch:                        ;очистка чек бокса
        mov   edx,dword ch_color   ;цвет внутри чек бокса
        jmp   @f             ;безусловный прыжок на нижнюю метку @@
check_box_draw_ch:            ;нарисовать включенный чек бокс
        mov   edx,dword ch_border_color        ;загрузить цвет
@@:
        movzx ebx,word ch_left  ;загрузить координату по х
        mov   eax,dword ch_size
        mov   bp,ax
        shr   eax,2
        push  ax
 
        push  ax
        add   ebx,eax           
        shl   ebx,16            ;сдвинем на 16 разрядов в лево (умножим на 65536)
        pop   ax
        lea   eax,[eax*2]
        sub   bp,ax             ;сохраним регистр bx в регистре указателя базы
        mov   bx,bp

        movzx ecx,word ch_top ;загрузить координату по у
        pop   ax
        add   cx,ax         
        shl   ecx,16          ;сдвинем на 16 разрядов в лево (умножим на 65536)
        mov   cx,bp           ;загрузим значения регистра указателя базы в cx
        mov   eax,13          ;в eax - значения функции для вывода полосы т.е. по сути прямоугольника, который отображает включенный компонент чек бокс
        mcall            ;вывод
ret                                ;выйти из процедуры
}


macro use_checkbox_mouse
{

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Обработчик mouse
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
check_box_mouse:      ;обработка мыши 
pusha
        mov     edi,dword [esp+36]
        mov     eax,37           ;будем что то делать если у нас что - нить нажато
        mov     ebx,2            ;внести в регистр значение 2
        mcall             ;проверка не нажал ли пользователь кнопку мышки
        test    eax,eax   ;проверка если у нас в eax=0, то установим флаг и выйдем
        jnz     @f         ;перейти на нижнюю метку @@
        btr     dword ch_flags,2  ;извлечение значения заданного бита в флаг cf и изменение его значения на нулевое. 
        jmp     check_box_mouse_end
        
@@:
        bts  dword ch_flags,2   ;проверка флага т.е. перенос в cf значение бита и установка бита в состояние включено
        jc   check_box_mouse_end         ;если CF=1 то перейти  в конец т.е. это выход
        mov  esi,dword ch_text_length ;загрузить кол-во символов в текстовой строке
        ;Умножение на 6 Быстрое умножение можно воспользоваться любым мз методов, но на старых Процессорах (386,486,P1)быстрее будет с инструкцией Lea
        lea esi,[eax*3]  
        shl esi,1
;        imul esi,6             ; или можно и так умножить на 6
        add  esi,dword ch_text_margin ;добавить 3 - расстояние от чек бокса до надписи

        mov  eax,37             ;получим координаты мышки 
        mov  ebx,1              ;добавить 1
        mcall               ;получить координаты курсора относительно окна 
        
        movzx ebx,word ch_top  ;загрузить в bx значение координаты у
        cmp   ax,bx              ;сравнить с с координатой курсора
        jl   check_box_mouse_end          ;SF <> OF если меньше 
        add   ebx,dword ch_size        ;добавить размер 
        cmp   ax,bx              ;сравнить
        jg   check_box_mouse_end          ;ZF = 0 и SF = OF если больше 
             
        shr   eax,16              ;разделим на 65536 или просто сдвинем биты на 16 значений
        movzx ebx,word ch_left  ;произведем аналогичное сравнение
        cmp   ax,bx            ;сравнить регистры
        jl   check_box_mouse_end        ;если меньше
        add   ebx,dword ch_size      ;добавить длину стороны прямоугольника
        add   ebx,esi          ;Учесть в значении по х еще и длину надписи к чекбоксу
        cmp   ax,bx            ;стравнить регистры
        jg   check_box_mouse_end        ;если больше 

        bts  dword ch_flags,1  ;извлечение значения заданного бита в флаг cf и изменение его значения на 1. 
        jc   @f                ;CF=1 то перейти на нижнюю @@
        
        call check_box_draw_ch        ;отобразить включенный чек бокс
;        mov   dword [esp+24],1 ;дальнейшая проверка чек боксов бесмыслена, по этому в стек, где располагается ecx поместитм 0 
        jmp  check_box_mouse_end       ;выйти 
@@:
        btr   word ch_flags,1  ;извлечение значения заданного бита в флаг cf и изменение его значения на нулевое. 
        call check_box_clear_ch         ;выключить чек бокс т.е. на месте закрашенного прямоугольника отобразить цвет фона.
check_box_mouse_end:
popa                                ;восстановить регистры из стека
ret  4                              ;выйти
}